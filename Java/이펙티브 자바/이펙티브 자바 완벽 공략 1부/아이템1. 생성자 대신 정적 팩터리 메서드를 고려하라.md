# 아이템1. 생성자 대신 정적 팩터리 메서드를 고려하라.

Java 에서 동일한 시그니처를 가진 생성자를 2개 이상 만들 수 없다.

(물론, 파라미터의 위치를 바꾸는 꼼수가 존재하지만 좋은 방법이 아니다.)

> 정적 팩터리 메서드는 디자인 패턴에서 나오는 추상 팩터리 패턴과 연관이 없다.

## 정적 팩터리 메서드의 장점

1. 정적 팩터리 메서드는 시그니처가 중복되는 경우, 생성자로는 알 수 없는 의미를 전달하기에 용이하다.

2. 인스턴스가 새로 만들어질 필요는 없다.

생성자가 열려있다면, 인스턴스를 통제할 수 없다.

어디서든 생성자로 새로운 인스턴스가 만들어질 수 있기 때문이다.

정적 팩터리 메서드는 플라이웨이트 패턴과 통용되는 점이 있다.

> 플라이웨이트

자주 사용하는 값들을 미리 캐싱해서 넣어두고 꺼내쓰는 패턴

3. 인터페이스 기반 프레임워크를 사용할 수 있다.

구체적인 타입을 클라이언트에 숨길 수 있다.

Java 8부터 팩터리 클래스를 만들지 않고 인터페이스 자체에서 정적 팩터리 메서드를 생성할 수 있다.

ex)

```java
public interface MyInterface {
	String myMethod();

	static MyInterface of(String name) {
			if (name.equals("first") {
				return new FirstService();
			} else {
				return new SecondService();
			}
	}
}
```

4. 매개변수에 따라서 다른 구현체를 반환할 수 있다.

5. 정적 팩터리 메서드 작성하는 시점에 구현체가 없어도 된다. (서비스 제공자 프레임워크)

`ServiceLoader` : Java에서 제공해주는 서비스 제공자 클래스

5번 장점은 특정 구현체와 의존성이 없다.

## 정적 팩터리 메서드의 단점

1. 상속이 어렵다.

정적 팩터리 메서드만을 사용하게 만든 클래스 → 생성자가 닫혀있다 → 상속이 불가능

하지만, 클래스를 위임하여 사용할 수 있다.

(만드는 사람의 의도에 따라 생성자를 열어두는 경우도 존재한다. ex) List)

1. 메서드가 많아진다면 Javadoc에서 정적 팩터리 메서드를 찾기가 어려워진다.

따라서, 흔히 많이 사용하는 네이밍패턴을 따르는게 좋다.

`from` : 하나의 매개 변수를 받아서 객체를 생성

`of` : 여러 개의 매개변수를 받아서 객체를 생성

`getInstance | instance` : 이미 만들어진 인스턴스를 가져옴

`newInstance | create` : 새로운 인스턴스 생성

`get` : 외부에서 다른 타입의 인스턴스를 생성

## 열거타입 : Enumeration

```java
public enum LifeCycle {
	WORKING, SLEEP, HOBBY, EXERCISING, STUDYING;
}
```

Enum은 Java 5부터 지원되는 타입이다.

JVM 내에서 하나의 인스턴스를 보장하며, 필드가 가질 수 있는 값들을 특정 값들로 제한할 수 있다는 장점을 가지고 있다.(Type safety)

Enum을 사용하면서 Set, Map을 사용해야 할 때는 EnumSet, EnumMap을 사용하는 것이 더 효율적이다.

## 플라이웨이트 패턴 (Flyweight)

같은 객체가 자주 요청되는 상황에는 플라이웨이트 패턴을 사용할 수 있다.

플라이웨이트 패턴은 객체를 가볍게 만들어 메모리 사용을 줄이는 패턴이다.

자주 변하는 속성과 변하지 않는 속성을 분리하고 재사용하여 메모리 사용을 줄일 수 있다.

## 인터페이스와 정적 메서드

interface에서 default method, static method를 가질 수 있다.

(자바 9부터 private static method도 가질 수 있다.)

## 서비스 제공자 프레임워크

패턴이나 프레임워크의 목적은 확장 가능한 애플리케이션을 만들기 위함이다.

확장 가능 : 코드 변경이 아닌 외적인 요소의 변화에도 애플리케이션이 작동되도록

서비스 제공자 인터페이스 (Service Provider Interface, SPI) : 여러 구현체들이 만들어질 수 있는 인터페이스

(구현제들이 같은 프로젝트에 있어도 되지만, 외부에 존재해도 상관 없다.)

서비스 제공 등록 API는 서비스 구현체를 등록하는 방법을 제공한다.

ex) 스프링의 `@Configuration` 내에서 `@Bean` 을 정의하는 방법 ← 서비스 구현체 등록 방법

서비스 접근 API : 서비스의 클라이언트가 서비스 인터페이스의 인스턴스를 가져올 때 사용하는 API

ex) Java의 `ServiceLoader`

브릿지 패턴은 구체적인 것과 추상적인 것을 나누는 디자인 패턴이다.

서로 영향을 주지 않으면서 구체적인 것과 추상적인 것이 각각 발달할 수 있도록 한다.

## 리플렉션

클래스로더를 통해 읽어온 클래스 정보를 사용하는 기술

클래스의 정보는 JVM에 들어있는 클래스로더가 읽어들인다.

이렇게 읽어들인 클래스 정보가 즉 리플렉션이다. (거울에 반영된, 반사된 실체가 아닌 것)

ex) 애노테이션 정보를 읽어들이는 것
