# Redis 클러스터 사양

Redis Cluster에 대한 공식문서를 기반으로 번역해가며 공부하는 문서입니다.

## 디자인의 주요 속성 및 근거

### Redis 클러스터 목표

Redis 클러스터는 설계 시 중요도 순으로 다음과 같은 목표를 가진 Redis의 분산 구현입니다.

- 최대 1000개 노드까지 높은 성능과 선형 확장성을 제공합니다. 프록시가 없고, 비동기 복제가 사용되며, 값에 대한 병합 작업이 수행되지 않습니다.
- 허용 가능한 쓰기 안전 수준 : 시스템은 대부분의 마스터 노드에 연결된 클라이언트에서 발생하는 모든 쓰기를 (최선의 노력으로) 보존하려고 합니다. 일반적으로 확인된 쓰기가 손실될 수 있는 작은 윈도우(시간대)가 존재합니다. 클라이언트가 소수 파티션에 있을 때 확인된 쓰기가 손실되는 윈도우(시간대)가 더 큽니다.
- 가용성 : Redis 클러스터는 대부분의 마스터 노드에 접근 가능하고 더 이상 접근 불가능한 마스터 노드에 대해 접근 가능한 복제본이 하나 이상 존재하는 파티션에서도 작동할 수 있습니다. 또한 복제본 마이그레이션을 사용하면, 어떤 복제본에도 더 이상 복제되지 않는 마스터는 여러 복제본으로 구성된 마스터로부터 복제본을 받게 됩니다.
  (Redis 3.0 이상에서 구현되는 항목들)

### 구현된 하위 집합

Redis 클러스터는 비분산형 Redis 버전에서 사용 가능한 모든 단일 키 명령을 구현합니다. 집합, 합집합 및 교집합과 같은 복잡한 다중 키 연산을 수행하는 명령은 해당 연산에 관련된 모든 키가 동일한 슬롯에 해시되는 경우에 구현됩니다.
Redis 클러스터는 해시 태그라는 개념을 구현하는데, 이를 통해 특정 키가 동일한 해시 슬롯에 저장되도록 강제할 수 있습니다. 그러나 수동 리샤딩 중에는 단일 키 작업은 항상 사용 가능하지만 다중 키 작업은 한동안 사용할 수 없게 될 수 있습니다.
Redis 클러스터는 독립형 Redis 버전처럼 여러 데이터베이스를 지원하지 않습니다. 데이터베이스는 0번만 있으며, SELECT 명령은 허용되지 않습니다.

## Redis 클러스터 프로토콜의 클라이언트 및 서버 역할

Redis 클러스터에서 노드는 데이터를 보관하고 클러스터 상태를 가져오는 역할을 하며, 키를 올바른 노드에 매핑하는 작업도 수행합니다. 또한 클러스터 노드는 다른 노드를 자동으로 검색하고, 작동하지 않는 노드를 감지하고, 장애 발생 시에도 계속 작동할 수 있도록 필요에 따라 복제본 노드를 마스터 노드로 승격시킬 수 있습니다.

모든 클러스터 노드는 작업을 수행하기 위해 TCP 버스와 Redis 클러스터 버스라는 바이너리 프로토콜을 사용하여 연결됩니다. 각 노드는 클러스터 버스를 통해 클러스터의 다른 모든 노드와 연결됩니다. 노드는 가십 프로토콜을 사용하여 클러스터에 대한 정보를 전파하여 새 노드를 검색하고, 다른 모든 노드가 제대로 작동하는지 확인하기 위해 ping 패킷을 전송하고, 특정 상태를 알리는 데 필요한 클러스터 메시지를 전송합니다. 클러스터 버스는 또한 클러스터 전체에 Pub/sub 메시지를 전파하고 사용자의 요청 시 수동 장애 조치를 조정하는 데에도 사용합니다.
(수동 장애 조치는 Redis 클러스터 장애 감지기가 아닌 시스템 관리자가 직접 시작하는 장애 조치입니다.)

클러스터 노드는 요청을 프록시할 수 없으므로, 클라이언트는 -MOVED 및 -ASK 리다이렉션 오류를 사용하여 다른 노드로 리다이렉션될 수 있습니다. 클라이언트는 이론적으로 클러스터의 모든 노드에 요청을 보낼 수 있으며, 필요한 경우 리다이렉션되므로 클러스터 상태를 유지할 필요가 없습니다. 하지만 키와 노드 간의 맵을 캐시할 수 있는 클라이언트는 성능을 상당히 향상시킬 수 있습니다.

### 쓰기 안전

Redis 클러스터는 노드 간 비동기 복제를 사용하며, 마지막 장애 조치가 암묵적 병합 기능을 이깁니다. 즉, 마지막으로 선출된 마스터 데이터 세트가 결국 다른 모든 복제본을 대체합니다. 파티션 작업 중에 쓰기 데이터가 손실될 수 있는 시간대가 항상 존재합니다. 그러나 이러한 시간대는 다수의 마스터에 연결된 클라이언트와 소수의 마스터에 연결된 클라이언트의 경우 매우 다릅니다.

Redis 클러스터는 소수 쪽에서 수행된 쓰기보다 다수의 마스터에 연결된 클라이언트에서 수행된 쓰기를 더 많이 보존하려고 합니다. 다음은 장애 발생 시 다수 쪽 파티션에서 수신된 확인된 쓰기가 손실되는 시나리오의 예입니다.

1. 쓰기는 마스터에 도달할 수 있지만, 마스터가 클라이언트에 응답할 수는 있어도 마스터와 복제본 노드 간에 사용되는 비동기 복제를 통해 복제본에 전파되지 않을 수 있습니다. 쓰기가 복제본에 도달하지 않고 마스터가 종료되면, 마스터에 오랫동안 접속할 수 없어 복제본 중 하나가 승격되면 쓰기는 영구적으로 손실됩니다. 마스터 노드가 갑자기 완전히 고장난 경우에는 마스터가 클라이언트(쓰기 확인 응답)와 복제본(쓰기 전파)에 거의 동시에 응답하려고 하기 대문에 이러한 현상을 관찰하기 어렵습니다. 하지만 이는 현실 세계에서 발생하는 장애 케이스입니다.
2. 이론적으로 쓰기가 손실되는 다른 장애 케이스는 다음과 같습니다.

- 파티션으로 인해 마스터에 접근 불가
- 해당 마스터의 복제본 중 하나에 장애 발생
- 시간이 지난 후 마스터에 접속 가능성 존재
- 오래된 라우팅 테이블을 사용하는 클라이언트는 클러스터에서 새 마스터의 복제본으로 변환되기 전에 이전 마스터에 쓸 수 있는 가능성 존재

2번째 장애 케이스는 발생할 가능성이 낮습니다. 마스터 노드가 장애 조치를 수행할 만큼 충분한 시간 동안 다른 마스터 노드들과 통신할 수 없으면 더 이상 쓰기를 허용하지 않기 때문입니다. 파티션이 고정된 경우에도 다른 노드가 구성 변경 사항을 알릴 수 있도록 잠시 동안 쓰기가 거부됩니다. 또한 이 장애 케이스는 클라이언트의 라우팅 테이블이 아직 업데이트되지 않았음을 요구합니다.

파티션의 소수 그룹을 대상으로 하는 쓰기는 손실될 가능성이 더 큽니다. 예를 들어, Redis 클러스터는 소수 그룹의 마스터와 하나 이상의 클라이언트가 있는 파티션에서 상당한 수의 쓰기 손실을 발생시킵니다. 마스터가 다수 그룹에서 장애 조치될 경우 마스터로 전송된 모든 쓰기가 손실될 가능성이 있기 때문입니다.

특히 마스터가 장애조최되려면 적어도 NODE_TIMEOUT 동안 과반수의 마스터에 의해서 접근할 수 없는 상태가 되어야 하고, 그래서 만약 파티션이 그 시간 이전에 해소되면 쓰기의 손실은 없습니다. 파티션이 NODE_TIMEOUT 이상 지속될 때, NODE_TIMEOUT 시간까지 소수 측에서 실행된 모든 쓰기가 손실될 수도 있습니다. 그러나 소수 측의 Redis 클러스터는 NODE_TIMEOUT 이 경과하자마자, 과반수 측과의 연락없이 쓰기는 거절하기 시작하므로, 최대의 시간이 존재하며, 그 이후에는 소수 쪽은 더 이상 사용할 수 없는 상태가 됩니다. 이런 이유로 이 시간 이후에는 쓰기가 받아들여지거나, 손실되지도 않습니다.
