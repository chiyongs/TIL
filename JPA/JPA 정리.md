# JPA 기본 정리

객체 지향 프로그래밍과 관계형 데이터베이스 간의 패러다임 불일치

- 상속
- 연관관계
- 데이터 타입
- 데이터 식별 방법

## 상속

상속관계의 객체를 DB에 저장하려면,
각각의 테이블에 따른 JOIN SQL을 작성하고, 각각의 객체를 생성하고 등등 여러 작업들이 필요하다.
→ DB에 저장할 객체에는 상속 관계를 사용하지 않게 됨

하지만, 자바 컬렉션에 저장된 객체는 조회 시 부모 타입으로 조회 후 다형성을 활용할 수 있다.

## 연관관계

테이블에 맞춰 객체를 모델링하게 되면 객체에 연관관계를 위한 외래 키 필드가 필요해진다.
하지만, 객체 지향에서는 객체 자체의 참조로 연관관계를 맺어서 객체 그래프를 순회할 수 있다.

## 엔티티 신뢰 문제

SQL로 데이터를 조회할 때 범위에 맞춰 데이터를 가져오게 되는데 객체 그래프를 순회할 때 해당 데이터가 조회되지 않아 데이터가 채워지지 않은 경우가 발생할 수 있다.
→ 용도에 따라 동일한 엔티티를 여러 번 조회해야 하는 경우가 발생

또한, 동일한 쿼리로 조회하여 만들어진 두 객체가 `==` 연산자로 비교 시 false가 나오게 된다.

객체를 객체답게 모델링할 수록 매핑 작업이 늘어남
→ 객체를 자바 컬렉션에 저장하듯이 DB에 저장하는 방법
→ JPA

## JPA

자바 진영의 ORM 기술의 표준

> ORM

Object-Relational Mapping

- 객체는 객체대로 설계하며 관계형 데이터베이스는 관계형 데이터베이스대로 설계
- ORM 프레임워크가 중간에서 매핑

이점
→ SQL 중심적인 개발에서 객체 중심으로 개발이 가능
→ 생산성 및 유지보수성 향상
→ 데이터 접근 추상화 및 벤더 독립성 등등..

### 생산성

CRUD

- Create : jpa.persist
- Read : jpa.find
- Update : entity.setXX
- Delete : jpa.remove

### 유지보수성

객체 필드 추가 시 SQL 자동 수정

### 성능 최적화

- 1차 캐시와 동일성 보장
  - 같은 트랜잭션 안에서는 같은 엔티티를 반환 → 약간의 조회 성능 향상
  - DB Isolation Level : Read Committed 여도 애플리케이션에서 Repeatable Read 보장
- 트랜잭션을 지원하는 쓰기 지연
  - 트랜잭션을 커밋할 때까지 Insert SQL을 모으고, JDBC BATCH SQL 기능을 사용해서 한 번에 SQL 전송
  - Update, Delete로 인한 Row 락 시간 최소화
  - 트랜잭션 커밋 시 Update, Delete SQL 실행하고 커밋
- 지연 로딩
  - 지연 로딩 : 객체가 실제 사용될 때 로딩
  - 즉시 로딩 : Join SQL로 한 번에 연관된 객체까지 미리 조회

## JPA 구동 방식

1. `Persistence` 클래스가 설정 정보를 조회
2. `Persistence` 클래스가 `EntityManagerFactory`를 생성
3. `EntityManagerFacotry`가 `EntityManager`를 생성

EntityManagerFactory : 1개만 생성해서 애플리케이션 전체에서 공유
EntityManager : 쓰레드 간 공유 X (사용 후 버려야 함)
JPA의 모든 데이터 변경은 트랜잭션 안에서 실행

## JPQL

JPQL : Java Persistence Query Language
-> JPA는 SQL을 추상화한 객체 지향 쿼리 언어를 제공
SQL과 문법이 유사
엔티티 객체를 대상으로 쿼리 -> 테이블이 아닌 객체를 대상으로 검색하는 객체 지향 쿼리
-> 데이터베이스에 의존적이지 않음

## 영속성 컨텍스트

JPA에서 가장 중요한 2가지

- 객체와 관계형 데이터베이스 매핑
- 영속성 컨텍스트

영속석 컨텍스트는 논리적인 개념으로 눈에 보이지 않는다.
엔티티매니저를 통해 영속성 컨텍스트에 접근 가능

엔티티매니저 : 영속성 컨텍스트 = N : 1

### 엔티티 생명주기

- 비영속(new / transient)
  - 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
- 영속 (managed)
  - 영속성 컨텍스트에 관리되는 상태
- 준영속 (detached)
  - 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 (removed)
  - 삭제된 상태

### 영속성 컨텍스트의 이점

- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지 (Dirty Checking)
- 지연 로딩

> 변경 감지
>
> 트랜잭션 커밋 요청이 들어오면 엔티티와 스냅샷을 비교하여 변경이 발생했다면 해당 변경에 대한 SQL을 생성하여 자동으로 반영해주는 기능

### flush

영속성 컨텍스트의 변경 내용을 데이터베이스에 반영
발생 기준

- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송

영속성 컨텍스트를 플러시하는 방법

- em.flush - 직접 호출
- 트랜잭션 커밋 - flush 자동 호출
- JPQL 쿼리 실행 - flush 자동 호출

영속성 컨텍스트를 비우지 않고, 영속성 컨텍스트의 변경내용을 DB에 동기화한다.
-> 트랜잭션 작업 단위가 중요! 커밋 직전에만 동기화하면 됨

### 준영속

영속 상태의 엔티티를 영속성 컨텍스트에서 분리
-> 영속성 컨텍스트의 기능을 사용 못함

준영속 상태로 만드는 방법

- em.detach(entity)
  - 특정 엔티티만 준영속 상태로 전환
- em.clear()
  - 영속성 컨텍스트 초기화
- em.close()
  - 영속성 컨텍스트 종료

## 엔티티 매핑

- 객체와 테이블 매핑 시 : `@Entity`, `@Table`
- 필드와 컬럼 매핑 시 : `@Column`
- 기본 키 매핑 시 : `@Id`
- 연관관계 매핑 시 : `@ManyToOne`, `@JoinColumn` …

> `@Entity` 사용시 주의사항

- 기본 생성자 필수
- final 클래스, enum, interface, inner 클래스 사용 X
- 저장할 필드에 final 사용 X

### 필드와 컬럼 매핑

- 컬럼 매핑 : `@Column`
- 날짜 타입 매핑 : `@Temporal`
- Enum 타입 매핑 : `@Enumerated`
  - EnumType.ORDINAL 사용 X → Enum 순서를 DB에 저장하기 때문에, Enum 순서 변경 시 데이터가 다 틀어짐
- BLOB, CLOB 매핑 : `@Lob`
- 특정 필드를 컬럼에 매핑하지 않음 : `@Transient`

### 기본 키 매핑

- `@Id`
- `@GeneratedValue`
  - IDENTITY : 데이터베이스에 위임, MySQL
  - SEQUENCE : 데이터베이스 시퀀스 오브젝트 사용, Oracle
    - DB에서 시퀀스 기능을 지원해야만 사용 가능한 전략
    - `@SequenceGenerator` 필요
  - TABLE : 키 생성용 테이블 사용, 모든 DB에서 사용 가능
    - `@TableGenerator` 필요
  - AUTO : 방언에 따라 자동 지정, 기본 값

## 연관관계 매핑

> 객체를 테이블에 맞춰 데이터 중심으로 모델링하면 협력 관계를 만들 수 없다.

테이블은 외래 키로 조인을 사용해 연관된 테이블을 찾는다.
객체는 참조를 사용해서 연관된 객체를 찾는다.
→ 패러다임 불일치

- 단방향 연관관계
- 양방향 연관관계
  - 양방향 매핑 규칙
    - 객체의 양방향은 사실 단방향 2개로 이루어진 것
    - 객체의 두 관계 중 하나를 연관관계의 주인으로 지정
    - 연관관계의 주인만이 외래 키를 관리 (연관관계의 주인 : 외래 키가 존재하는 곳)
    - 주인이 아닌 쪽은 읽기만 가능
    - 주인은 mappedBy 속성 사용 X
    - 주인이 아니면 mappedBy 속성으로 주인 지정
  - 연관관계 편의 메소드 생성
  - 양방향 매핑 시 무한 루프 조심
    - toString, lombok, json 생성 라이브러리
  - 단방향 매핑만으로도 이미 연관관계 매핑은 완료되었지만 양방향 매핑을 통해 반대 방향으로 조회 기능이 추가된 것뿐이다.
  - 따라서, 단방향 매핑만 사용하고 필요할 때 양방향을 추가해도 됨 (테이블에 영향 주지 않음)

### 다양한 연관관계 매핑

연관관계 매핑 시 다중성, 단방향&양방향, 연관관계의 주인 이 3가지를 고려해야 한다.

> 다대일 N:1

- 다대일 단방향
  - 가장 많이 사용하는 연관관계
  - 반대는 일대다
- 다대일 양방향
  - 외래 키가 있는 쪽이 연관관계의 주인
  - 양쪽 객체가 서로를 참조

> 일대다 1:N

- 일대다 단방향
  - 일이 연관관계의 주인 → 테이블에서는 다 쪽에 외래 키가 존재
  - 객체와 테이블의 차이로 반대편 테이블의 외래 키는 관리하는 특이한 구조
  - `@JoinColumn`을 꼭 사용!, 그렇지 않으면 중간에 테이블을 하나 추가하는 조인 테이블 방식을 사용함
  - 따라서, 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용 권장
- 일대다 양방향
  - 공식적으로 존재하지 않는 방식
  - 다대일 양방향을 사용해야 함

> 일대일 1:1

주 테이블이나 대상 테이블 중 외래 키 선택 가능한 형태

- 주 테이블에 외래 키가 존재하는 단방향
  - 다대일 단방향 매핑과 유사
- 주 테이블에 외래 키가 존재하는 양방향
  - 다대일 양방향 매핑과 유사
  - 외래 키가 있는 곳이 연관관계의 주인, 반대편은 mappedBy 적용
- 대상 테이블에 외래 키가 존재하는 단방향
  - JPA에서 지원하지 않음
- 대상 테이블에 외래 키가 존재하는 양방향
  - 주 테이블에 외래 키가 존재하는 양방향과 같음

주 테이블에 외래 키가 존재하는 방법은 객체 지향 개발자가 선호하며 JPA 매핑이 편리하다.
주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인이 가능하지만, 값이 없으면 외래 키에 null이 허용된다.

대상 테이블에 외래 키가 존재하는 방법은 전통적인 데이터베이스 개발자가 선호한다.
주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경하여도 테이블 구조가 유지되지만, 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩된다.

> 다대다 N:M

관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현 불가능
→ 연결 테이블을 추가하여 일대다, 다대일 관계로 풀어야함
→ 객체는 컬렉션을 사용해 객체 2개로 다대다 관계 가능

`@ManyToMany` 를 사용하여 다대다 매핑을 할 수 있지만 실무에서는 사용하지 않음
→ 연결 테이블이 단순히 연결만 하지 않고 추가적인 정보를 가져야하는 경우가 많기 때문
→ 중간 테이블을 엔티티로 승격하여 관리

### 고급 매핑 - 상속 관계 매핑

관계형 데이터베이스는 상속 관계가 없다.
슈퍼 타입-서브 타입 관계 모델링 기법이 객체 상속과 유사

- 각각의 테이블로 변환 → 조인 전략
- 통합 테이블로 변환 → 단일 테이블 전략
- 서브타입 테이블로 변환 → 구현 클래스마다 테이블 전략

> 조인 전략

장점 : 테이블 정규화, 외래 키 참조 무결성 제약조건 활용가능, 저장공간 효율화
단점 : 조회 시 조인을 많이 사용 → 성능 저하, 조회 쿼리 복잡

> 단일 테이블 전략

장점 : 조인 X → 일반적으로 조회 성능 빠름, 조회 쿼리 단순
단점 : 자식 엔티티가 매핑한 컬럼은 모두 null 허용, 단일 테이블에 모든 것을 저장 → 테이블이 커질 수 있음

> 구현 클래스마다 테이블 전략

추천 X

> `@MappedSuperclass`

공통 매핑 정보가 필요 시 사용
직접 생성해서 사용할 일이 없으므로 추상 클래스 권장
상속관계 매핑이 아니며, 엔티티도 아니고, 테이블과 매핑되지 않는다.
→ 조회, 검색 불가

부모 클래스를 상속받는 자식 클래스에 매핑 정보만 제공한다.
테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할

주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용
참고 : `@Entity` 클래스는 다른 엔티티나 `@MappedSuperclass` 로 지정한 클래스만 상속 가능

## 프록시

EntityManager.find() : 데이터베이스를 통해 실제 엔티티 객체 조회
EntityManager.getReference() : 데이터베이스 조회를 미루는 프록시 엔티티 객체 조회

프록시 객체는 실제 클래스를 상속받아서 만들어지고 실제 클래스와 겉모양이 같음
→ 사용하는 입장에서 구분하지 않고 사용 가능

프록시 객체는 실제 객체의 참조를 가지며, 프록시 객체 호출 시 실제 객체의 메소드를 호출

- 처음 사용 시에 한 번만 초기화
- 프록시 객체를 초기화하는 것이 프록시 객체가 실제 엔티티로 바뀌는 것은 아님. 프록시 객체 그대로

→ 타입 체크 시 == 연산자로 비교하면 실패함 → instanceOf 사용

- 영속성 컨텍스트에 실제 엔티티가 이미 존재하는 상태에서 프록시 객체를 조회한다면 실제 엔티티를 반환해줌

## 지연 로딩과 즉시로딩

> 지연 로딩

`@ManyToOne(fetch = FetchType.LAZY)`

지연로딩을 통해 프록시 객체를 가지고 있다 실제 엔티티 객체가 필요한 시점에 DB 조회

> 즉시 로딩

`@ManyToOne(fetch = FetchType.EAGER)`

즉시로딩 시 연관된 엔티티를 Join을 사용해서 항상 한 번에 같이 조회
실무에서는 가급적 지연 로딩만 사용하는 것을 권장
즉시 로딩 사용시 예상치 못한 SQL 발생 & JPQL에서 N+1 문제 발생

### N+1 문제

JPA에서 연관관계 매핑된 엔티티를 조회 시 의도치 않은 n번의 추가 쿼리가 발생하는 문제
지연 로딩, 즉시 로딩과의 연관성보단 JPQL로 인해 발생하는 문제
JPQL은 연관관계 데이터를 무시하고 해당하는 엔티티만을 조회하기 때문에 연관된 엔티티 데이터가 필요한 경우 FetchType으로 지정한 시점에 조회를 별도로 또 호출하게 된다.

해결방법

- Fetch join
- BatchSize
- FetchMode.SUBSELECT
- EntityGraph

### 영속성 전이 Cascade

특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶은 경우
(연관관계 매핑과는 관련이 없음, 그저 엔티티 영속화 시 연관된 엔티티도 함께 영속화하는 편리함만을 제공할 뿐)

- ALL : 모두 적용
- PERSIST : 영속
- REMOVE : 삭제
- MERGE : 병합
- REFRESH : 갱신
- DETACH : DETACH

### 고아 객체

부모 엔티티와 연관관계가 끊어진 자식 엔티티
`orphanRemoval=true` → 고아 객체 자동 삭제

참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 판단하여 삭제하는 기능
→ 참조하는 곳이 한 곳이어야 하고, 특정 엔티티가 해당 엔티티를 개인으로 소유할 때 사용
→ `@OneToOne`, `@OneToMany` 만 가능
