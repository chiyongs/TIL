# 아이템10. equals는 일반 규약을 지켜 재정의하라

## Equals가 필요없는 경우

equals를 재정의할 필요가 없는 상황이면 재정의하지 않는 것이 최선이다.

- 각 인스턴스가 본질적으로 고유한 경우(ex. 싱글톤, Enum)
- 인스턴스의 ‘논리적 동치성’을 검사할 필요가 없는 경우(ex. 5만원권 2장, 문자열)
  - Object가 제공하는 기본적인 equals는 객체의 동일성을 비교한다.
- 상위 클래스에 재정의한 equals가 하위 클래스에도 적절한 경우
- 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없는 경우

## Equals 규약

- 반사성
  - A.equals(A) == true
- 대칭성

  - A.equals(B) == B.equals(A)
  - 예시

  ```java
  public class CaseInsensitiveString {
  	private final String s;

  	// 대칭성을 위배한 equals
  	@Override
  	public boolean equals(Object o) {
  		if (o instanceof CaseInsensitiveString)
  			return s.equalsIgnoreCase((CaseInsensitiveString) o.s);
  		if (o instanceof String) // 한 방향으로만 작동한다.
  			return s.equalsIgnoreCase((String) o);
  		return false;
  	}

  	public static void main(String[] args) {
  		CaseInsensitiveString cis = new CaseInsensitiveString("Polish");
  		String str = "polish";
  		boolean result1 = cis.equals(str); // true
  		boolean result2 = str.equals(cis); // false
  		// result1 == true, result2 == false -> 따라서, 대칭성 위배
  		// 대칭성을 성립하기 위해서 다른 타입을 지원하지 않아야
  		// cis.equals(str) == false, str.equals(cis) == false가 되어 대칭성이 성립
  	}
  }
  ```

- 추이성
  - A.equals(B) && B.equals(C) → A.equals(C)
  - equals 규약을 지키면서 값 추가하기 : composition
    - 상속을 받는 것이 아니라 Composite 디자인 패턴을 활용해서 클래스 내 필드로 가져간다.
- 일관성
  - A.equals(B) == A.equals(B)
  - 객체 안에 들어있는 값이 바뀐다면 일관성이 깨질 수 있지만, 불변 객체라면 일관성을 항상 보장된다.
  - 일관성을 지키면서 equals를 구현하기 위해서 너무 복잡하면 안된다.
- null-아님
  - A.equals(null) == false

## Equals 구현 방법

Equals를 구현할 때는 4가지 방법을 따르면 된다.

1. == 연산자를 사용해 자기 자신의 참조인지 확인한다.
2. instanceof 연산자로 올바른 타입인지 확인한다.
3. 입력된 값을 올바른 타입으로 형변환 한다.
4. 입력 객체와 자기 자신의 대응되는 핵심 필드가 일치하는지 확인한다.

이런 방법을 따라 Equals를 만들 수 있지만, Equals를 재정의하는 것은 그리 좋지 않다.
이러한 규약을 다 따르면서 구현하는 것도 어렵다.
