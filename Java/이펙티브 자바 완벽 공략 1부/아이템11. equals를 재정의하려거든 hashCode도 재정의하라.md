# 아이템11. equals를 재정의하려거든 hashCode도 재정의하라

## hashCode 규약

equals 비교에 사용하는 정보가 변경 X → hashCode는 매번 같은 값을 리턴해야 함

두 객체에 대한 equals가 같다면 → hashCode도 같아야한다.

두 객체에 대한 equals가 다르다면 → hashCode 값이 같을 수 있지만 해시 테이블 성능을 고려해 다른 값을 리턴하는 것이 좋다.

hashCode를 구현할 때에는 equals 구현 시 사용한 모든 필드들을 사용해야 한다.

> HashMap에 넣을 때와 꺼낼 때로 hashCode 구현의 필요성을 알 수 있다.

HashMap에 객체를 넣는 과정에서 hashCode 메서드를 실행하여 어느 bucket에 넣을지 결정한다.

꺼낼 때도 hashCode 값을 먼저 가져와서 해당 값에 해당하는 객체를 꺼낸다.

다른 두 객체가 같은 hashCode를 가질 수 있다.
그런 경우에 HashMap도 정상적으로 작동한다.
하지만, 이런 경우 HashMap을 사용하는 의미가 줄어든다. HashMap의 hash를 사용하여 탐색 시에 O(1)의 좋은 효율을 보여주지만, 다른 객체가 같은 hash 값을 가지게 된다면 그것은 List를 사용하는 것과 같이 O(n)이 되버리기 때문이다.

## hashCode 구현 방법

```java
@Overrie
public int hashCode() {
	int result = Short.hashCode(firstImportantField); // 1
	result = 31 * result + Short.hashCode(secondImportantField); // 2
	result = 31 * result + Short.hashCode(thirdImportantField); // 3
	return result;
}
```

1. 핵심 필드 중 하나의 값의 해시값을 계산한다.
   1. 만약, 해당 값이 primitive type이면 wrapper type의 hashCode 메소드를 사용해서 해시값을 구하면 된다.
   2. primitive type이 아닌 경우, 해당 Reference가 가지고 있는 hashCode 메소드를 사용한다.
2. 그 후 첫 핵심 필드의 해시값에 특정 숫자를 곱하고 다른 핵심 필드의 해시값을 더하는 과정을 반복한다.

> 위 예시에서 곱한 특정 숫자가 31인 이유

1. 홀수를 써야됨. 짝수를 써서 연산을 하면 뒤에 0이 채워지면서 숫자가 왼쪽으로 밀리면서 날아갈 수 있다.
2. 홀수 중에서 왜 31이냐 → 사전에 들어있는 모든 단어를 해시해보면서 어떤 숫자를 썼을 때 가장 해시 충돌이 적게 일어나는지 연구했는데 그 숫자가 31이다.

하지만, 개발하면서 위처럼 hashCode를 직접 구현하지는 않고 IDE의 지원을 받는 경우가 많다.

```java
@Override
public int hashCode() {
	return Objects.hash(first, second ...);
}
```

hashCode를 자주 사용하는 경우에는 hashCode를 계속 계산해야하므로 캐싱을 사용하는 것이 좋다.
하지만, 해당 객체가 불변 클래스인 경우에 가능하며 스레드 안전성까지도 고려해야 한다.

### 해시 코드 구현 시 주의할 점

- 지연 초기화 기법을 사용할 때 스레드 안전성을 신경써야 한다.
- 성능 때문에 핵심 필드를 해시코드 계산 시 빼면 안된다.
- 해시코드 계산 규칙을 API에 노출하지 않는 것이 좋다.

## 해시맵 내부의 연결 리스트

Java 8에서 해시 충돌 시 성능 개선을 위해 내부적으로 동일한 버켓에 일정 개수 이상의 엔트리가 추가된다면, 연결 리스트 대신 이진 트리를 사용하도록 바뀌었다.

연결 리스트를 사용하게 되면 데이터 탐색 시 O(n)의 시간이 소요되지만, 이진 트리(Red-black 트리)를 사용하게 되면 O(log n)이 걸리게 되므로 성능 최적화가 진행되었다.
