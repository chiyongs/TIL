# 4장. 분산 메시지 큐

분산 메시지 큐 사용 시 이점

- 결합도 완화 : 강결합 사라짐
- 규모 확장성 개선 : 생산자와 소비자가 독립적
- 가용성 개선 : 개별 컴포넌트의 장애와 상관없이 다른 컴포넌트는 큐와 상호작용
- 성능 개선 : 비동기 통신 가능

## 기능 요구사항

- 생산자는 메시지 큐에 메시지를 보낼 수 있어야 한다.
- 소비자는 메시지 큐를 통해 메시지를 수신할 수 있어야 한다.
- 메시지는 반복적으로 수신 or 단 한 번만 수신하도록 설정
- 오래된 이력 데이터 삭제될 수 있다.
- 메시지 크기는 킬로바이트 수준
- 메시지는 생산된 순서대로 소비자에게 전달
- 메시지 전달 방식은 최소 한 번, 최대 한 번, 정확히 한 번 가운데 설정할 수 있어야 한다.

## 비기능 요구사항

- 높은 대역폭과 낮은 전송 지연 가운데 하나를 설정할 수 있어야 하는 기능
- 규모 확장성, 메시지 양이 급증해도 처리 가능해야 함
- 지속성 및 내구성, 데이터는 디스크에 지속적으로 보관 & 여러 노드에 복제되어야 함

### 전통적 메시지 큐와 다른 점

전통적 메시지 큐 : 메시지 보관 문제 중요 X
-> 메시지가 소비자에게 전달되기 충분한 기간동안만 메모리에 보관
메시지 전달 순서도 보존 X
-> 생산된 순서와 소비되는 순서 다를 수 있음

## 메시지 모델

### 일대일 (point to point)

- 전통적인 메시지 큐에서 흔히 발견되는 모델
- 오직 한 소비자만 메시지를 소비
- 데이터 보관 (Data Retention) 지원 X

과정

1. 소비지가 메시지 가져감
2. 소비자가 큐에 알림 (Acknowledge)
3. 메시지 큐에서 삭제

### 발행-구독 (publish-subscribe)

토픽 : 메시지를 주제별로 정리하는 데 사용
각 토픽은 메시지 큐 서비스 전반에 고유한 이름을 가짐

토픽에 전달된 메시지는 해당 토픽을 구독하는 모든 소비자에게 전달

#### 토픽, 파티션, 브로커

토픽에 보관되는 데이터의 양이 커져서 서버 한 대로 감당이 어려움
-> 파티션 사용으로 해결 가능
토픽을 여러 파티션으로 분할한 다음, 메시지를 모든 파티션에 균등하게 나눠 보냄
-> 파티션 : 토픽에 보낼 메시지의 작은 부분 집합

파티션은 메시지 큐 클러스터 내의 서버에 고르게 분산 배치함
파티션을 유지하는 서버 -> 브로커
파티션을 브로커에 분산하는 것이 높은 규모 확장성을 달성하는 비결
토픽의 용량을 확장하고 싶으면 파티션 개수를 늘리면 됨

각 토픽 파티션은 FIFO로 동작
-> 같은 파티션 안에서는 메시지 순서가 유지됨

생산자가 보낸 메시지는 해당 토픽의 파티션 중 하나로 보내짐

- 같은 키를 가진 모든 메시지는 같은 파티션으로 보내짐
- 키가 없는 메시지는 랜덤한 파티션으로 보내짐

토픽을 구독하는 소비자는 하나 이상의 파티션에서 데이터를 가져오게 된다.
-> 소비자가 파티션보다 많으면 유휴 소비자 발생 가능

#### 소비자 그룹

하나의 소비자 그룹은 여러 토픽 구독 & 오프셋을 별도로 관리
같은 그룹 내의 소비자는 메시지를 병렬로 소비 가능
-> 병렬로 소비 시 대역폭 좋음, 하지만 같은 파티션 안에 있는 메시지를 순서대로 소비 불가능
-> 소비 순서 보장 불가능

소비 순서 보장 방법
: 어떤 파티션의 메시지는 한 그룹 안에서는 오직 한 소비자만 읽을 수 있도록 강제
-> 그룹 내 소비자 수가 구독하는 토픽의 파티션 수보다 많으면 유휴 소비자 발생

## 개략적 설계안

클라이언트

- 생산자 : 메시지를 특정 토픽으로 보낸다
- 소비자 그룹 : 토픽을 구독하고 메시지를 소비한다

핵심 서비스 및 저장소

- 브로커 : 파티션들을 유지, 하나의 파티션은 특정 토픽에 대한 메시지의 부분 집합을 유지
- 데이터 저장소 : 메시지는 파티션 내 데이터 저장소에 보관
- 상태 저장소 : 소비자 상태 저장
- 메타데이터 저장소 : 토픽 설정, 토픽 속성 등 저장
- 조정 서비스
  - 서비스 탐색 (Service Discovery) : 어느 브로커가 살아있는지
  - 리더 선출 : 브로커 가운데 하나는 컨트롤러 역할을 담당. 한 클러스터에는 반드시 활성 상태의 컨트롤러가 1개는 존재해야함. 파티션 배치를 책임

## 상세 설계

데이터 장기 보관 및 높은 대역폭 제공을 위한 3가지 결정

- 디스크 기반 자료구조 활용
- 메시지가 생산자 -> 소비자에게 전달되는 순간까지 아무 수정 없이 전송 가능한 메시지 자료구조
- 일괄 처리를 우선하는 시스템 설계, 소규모 I/O 많으면 높은 대역폭 지원 어려움.
  생산자는 메시지 일괄 전송, 메시지 큐는 그 메시지들을 더 큰 단위로 묶어 보관, 소비자도 가능하면 메시지 일괄 수신

### 데이터 저장소

메시지 큐의 트래픽 패턴

- 읽기와 쓰기가 빈번하게 발생
- 갱신/삭제 연산은 발생 X
- 순차적인 읽기/쓰기가 대부분

WAL (Write Ahead Log), 쓰기 우선 로그
: 새로운 항목이 추가되기만 하는 append-only 일반 파일
MySQL의 복구 로그 (redo log), 아파치 주키퍼에서도 활용

지속성을 보장해야 하는 메시지는 디스크에 WAL로 보관할 것을 추천
WAL의 접근 패턴 : 읽기/쓰기 전부 순차적
-> 접근 패턴이 순차적일때 디스크는 아주 좋은 성능을 보임

새로운 메시지는 파티션 꼬리 부분에 추가, 오프셋은 그 결과로 점진적으로 증가
세그먼트 단위로 관리.
비활성 세그먼트 파일은 보관 기한이 만료되거나 용량 한계에 도달하면 삭제

#### 디스크 성능 관련 유의사항

데이터 장기 보관에 대한 요구사항으로 인해 디스크 드라이브 활용하여 대량의 데이터 보관
회전식 디스크가 느린 것은 데이터 접근 패턴이 무작위일 때.
메시지 큐에서는 데이터 접근 패턴이 순차적이므로 충분히 적합한 성능 발휘.

현대적 운영체제는 디스크 데이터를 메모리에 아주 적극적으로 캐시
-> WAL도 OS가 제공하는 디스크 캐시 기능을 적극적으로 활용

### 메시지 자료 구조

메시지 자료구조는 높은 대역폭 달성의 열쇠
메시지가 큐를 거쳐 소비자에게 전달되는 과정에서 불필요한 복사가 일어나지 않도록 해야 높은 대역폭 달성 가능

필드 이름 : 데이터 자료형

- key : byte[]
- value : byte[]
- topic : string
- partition : integer
- offset : long
- timestamp : long
- size : integer
- crc : integer

#### 메시지 키

파티션을 정할 때 사용

- 키가 주어지지 않은 메시지는 파티션이 무작위로 결정
- 키가 주어진 메시지는 파티션이 hash(key) % numPartitions 공식에 따라 결정

더 유연한 설계가 필요하다면 생산자는 직접 파티션 선정 메커니즘을 정의 가능

키에는 비즈니스 관련 정보가 담기는 것이 보통

#### 메시지 값

메시지의 내용, 즉 payload

#### 메시지의 기타 필드

- 토픽 : 메시지가 속한 토픽의 이름
- 파티션 : 메시지가 속한 파티션의 ID
- 오프셋 : 파티션 내의 메시지의 위치. 메시지는 토픽, 파티션, 오프셋 세 가지 정보를 알면 찾을 수 있다.
- 타임스탬프 : 메시지가 저장된 시각
- 크기 : 메시지의 크기
- CRC : 순환 중복 검사, 주어진 데이터의 무결성을 보장하는데 이용

### 일괄 처리

일괄처리 : 시스템 성능에 아주 중요

이유

- 운영체제로 하여금 여러 메시지를 한 번의 네트워크 요청으로 전송할 수 있도록 하기 때문에 값비싼 네트워크 왕복 비용 제거 가능
- 브로커가 여러 메시지를 한 번에 로그에 기록하면 더 큰 규모의 순차 쓰기 연산이 발생 -> 디스크 캐시에서 더 큰 규모의 연속된 공간을 점유 가능

높은 대역폭과 낮은 응답 지연은 동시에 달성하기 어려운 목표
시스템이 낮은 응답 지연이 중요한 전툥적 메시지 큐로 이용된다면 일괄 처리 메시지 양은 낮춘다.
-> 디스크 성능은 다소 낮아진다

처리량을 높여야 한다면 토픽당 파티션의 수를 늘린다
-> 낮아진 순차 쓰기 연산 대역폭을 발충할 수 있다

### 생산자 측 작업 흐름

생산자가 어떤 파티션에 메시지를 보내야할 때 어느 브로커에 연결해야 할까?
-> 해결책 : 라우팅 계층
라우팅 계층이 적절한 브로커에 메시지를 보내는 역할을 담당
메시지를 받을 적절한 브로커 : 리더 브로커

생산자 내부에 라우팅 계층을 두고 버퍼를 도입
생산자 클라이언트 라이브러리의 일부로 생산자에 설치
-> 생산자에서 라우팅 계층으로의 네트워크를 거칠 필요가 없으므로 전송 지연 감소
-> 생산자는 메시지를 어느 파티션에 보낼지 결정하는 자신만의 로직을 가질 수 있음
-> 저송할 메시지를 버퍼 메모리에 보관했다가 목적지로 일괄 전송하여 대역폭을 높일 수 있음

- 일괄 처리 메시지의 양을 늘리면 대역폭 증가 but 응답 속도 느려짐
  :일괄 처리가 가능할 양의 메시지를 기다려야 함
- 양을 줄이면 메시지는 더 빨리 보낼 수 있으니 지연은 줄어들지만 대역폭 손해

생산자는 메시지 큐의 용도를 감안하여 일괄 처리 메시지 양을 조정해야 함

### 소비자 측 작업 흐름

소비자는 특정 파티션의 오프셋을 주고 해당 위치에서부터 이벤트를 묶어 가져온다

#### 푸쉬 vs 풀

푸쉬 모델

- 장점
  - 낮은 지연 : 브로커는 메시지를 받는 즉시 소비자에게 보낼 수 있다.
- 단점
  - 소비자의 메시지 처리 속도보다 생신자의 메시지 생산 속도가 빠를 경우, 소비자에게 큰 부하 발생
  - 생산자가 데이터 전송 속도를 좌우하므로, 소비자의 컴퓨팅 자원은 생산자에 의존적으로 준비 필요

풀 모델

- 장점
  - 메시지 소비 속도를 소비자가 알아서 결정
  - 메시지 소비 속도가 생산 속도보다 느려지면 소비자를 늘려 해결하거나 생산 속도를 따라잡을 때까지 기다릴 수도 있음
  - 일괄 처리에 적합. 소비자가 지난번 마지막으로 가져간 로그 위치 다음에 오는 모든 메시지를 한 번에 가져갈 수 있음. 공격적 일괄 처리에 좀 더 적합
- 단점
  - 브로커에 메시지가 없어도 소비자는 계속 데이터를 끌어가려 시도, 소비자 측 컴퓨팅 자원이 낭비됨. 롱 폴링 모드로 극복 (당장은 가져갈 메시지가 없더라도 일정 시간은 기다리도록 하는 것)

동작 흐름

1. 토픽 구독을 원하는 새로운 소비자 등장. 그룹 이름을 해싱하여 접속할 브로커 노드를 찾음. 같은 그룹의 모든 소비자는 같은 브로커에 접속. 해당 브로커는 해당 소비자 그룹의 코디네이터. 코디네이터는 소비자 그룹의 조정 작업만 담당
2. 코디네이터는 해당 소비자를 그룹에 참여시키고 해당 소비자에게 파티션을 할당
3. 소비자는 마지막으로 소비한 오프셋 이후 메시지를 가져온다. 오프셋 정보는 상태 저장소에 존재
4. 소비자는 메시지를 처리하고 새로운 오프셋을 브로커에 보낸다. 데이터 처리와 오프셋 갱신 순서는 메시지 전송 시맨틱에 영향을 미침

### 소비자 재조정

어떤 소비자가 어떤 파티션을 책임지는지 다시 정하는 프로세스

- 새로운 소비자의 합류
- 기존 소비자의 이탈
- 특정 소비자의 장애 발생
- 파티션 조정
  위 경우에 소비자 재조정 프로세스 시작

소비자 재조정에는 코디네이터가 중요한 역할을 함
코디네이터 : 소비자 재조정을 위해 소비자들과 통신하는 브로커 노드
소비자로부터 오는 하트비트 메시지를 살피고 각 소비자의 파티션 내 오프셋 정보를 관리

- 같은 그룹의 모든 소비자는 같은 코디네이터에 연결
- 코디네이터는 자신에 연결한 소비자 목록을 유지. 이 목록에 변화가 생기면 코디네이터는 해당 그룹의 새 리더를 선출
- 새 리더는 새 파티션 배치 계획을 만들고 코디네이터에게 전달. 코디네이터는 해당 계획을 그룹 내 다른 모든 소비자에게 알림

소비자 장애 감지 시 코디네이터는 재조정 프로세스를 시작하여 파티션을 재배치함

#### 재조정 시나리오

코디네이터는 소비자 재조정이 필요할 시 모든 소비자에게 그 사실을 수동적으로 통지
-> 소비자의 하트비트 메시지가 왔을 때 그 응답으로 그룹에 다시 합류하라고 알림

모든 소비자의 그룹 합류 이후 리더 선출, 그룹 동기화 요청, 리더로부터 받은 파티션 배치 계획 전파

### 상태 저장소

- 소비자에 대한 파티션의 배치 관계
- 각 소비자 그룹이 각 파티션에서 마지막으로 가져간 메시지의 오프셋
  를 저장한다.

소비자 상태 정보 데이터가 이용되는 패턴

- 읽기와 쓰기가 빈번하게 발생, 양은 많지 않음
- 데이터 갱신은 빈번하게 일어나지만 삭제되는 일은 거의 없음
- 읽기와 쓰기 연산은 무작위적 패턴
- 데이터의 일관성이 중요

-> 아파치 주키퍼와 같은 키-값 저장소 사용이 바람직

### 메타데이터 저장소

토픽 설정이나 속성 정보를 보관
(파티션 수, 메시지 보관 기간, 사본 배치 정보 등)

메타데이터는 자주 변경되지 않으며 양도 적다. 하지만 높은 일관성을 요구
-> 주키퍼가 적절

#### 주키퍼

계층적 키-값 저장소
-> 분산 시스템에 필수적인 서비스

- 메타데이터와 상태 저장소는 주키퍼를 이용해 구현
- 브로커는 이제 메시지 데이터 저장소만 유지
- 주키퍼가 브로커 클러스터의 리더 선출 과정을 돕는다

### 복제

분산 시스템에서 하드웨어 장애는 흔한 일, 디스크에 손상이나 영구적 장애 발생 시 데이터 유실
-> 높은 가용성 보장을 위해 복제 사용

사본들은 서로 다른 브로커 노드에 분산
생산자는 파티션에 메시지를 보낼 때 리더에게만 보냄
다른 사본은 리더에서 새 메시지를 지속적으로 가져와 동기화
메시지를 완전히 동기화한 사본의 개수가 지정된 임계값을 넘으면 리더는 생산자에게 메시지를 잘 받았다는 응답을 보냄

사본 분산 계획 : 사본을 파티션에 어떻게 분산할지 기술하는 것
-> 조정 서비스의 도움으로 브로커 노드 중 하나가 리더로 선출되면 해당 리더 브로커 노드가 사본 분산 계획을 만들고 메타데이터 저장소에 보관

#### 사본 동기화

어떤 한 노드의 장애로 메시지가 소실되는 것을 막기 우해 메시지는 여러 파티션에 두며 각 파티션은 다시 여러 사본으로 복제
-> 문제는 그 모두를 어떻게 동기화시킬 것인지
동기화된 사본 : In-Sync Replicas, ISR은 리더와 동기화된 사본

리더와 사본의 합의된 오프셋까지 동기화되었다면 해당 사본은 ISR.
ISR이 필요한 이유 : 성능과 영속성 사이의 타협점
생산자가 보낸 어떤 메시지도 소실하지 않는 가장 안전한 방법
: 생산자에게 메시지를 잘 받았다는 응답을 보내기 전에 모든 사본을 동기화하는 것
-> 어느 사본 하나라도 동기화를 신속하게 처리하지 못한다면 파티션 전부가 느려지거나 아예 못 쓰게 되는 일 발생

#### ACK=all

생산자는 모든 ISR이 메시지를 수신한 뒤에 ACK 응답을 받는다.
느린 ISR의 응답을 기다려야 하므로 메시지를 보내기 위한 시간이 길어진다.
메시지의 영속성 측면에서는 가장 좋은 구성

#### ACK=1

생산자는 리더가 메시지를 저장하고 나면 바로 ACK 응답을 받는다
데이터가 동기화될 때까지 기다리지 않아서 응답 지연은 개선된다.
메시지 ACK를 보낸 직후 리더에 장애가 생기면 해당 메시지는 다른 사본에 반영되지 못했으므로 영구 소실됨
데이터가 사라져도 상관없는 대신 낮은 응답 지연을 보장해야 하는 시스템에 적합

#### ACK=0

생산자는 보낸 메시지에 대한 수신 확인 메시지를 기다리지 않고 계속 메시지 전송하며 어떤 재시도도 하지 않음
지표 수집이나 데이터 로깅 등 처리해야 하는 메시지의 양이 많고 때로 데이터 손실이 발생해도 상관 없는 경우에 좋다.

ACK 설정이 변경 가능하면 성능을 높여야 할 경우 영속성을 다소 희생할 수도 있다.

소비자 측에서는 가장 쉬운 구성은 소비자로 하여금 리더에게 메시지를 읽어가도록 하는 것

리더 사본에 요청이 너무 몰리거나 ISR 요건을 만족하는 사본에서 메시지를 가져가지 않는 이유

- 설계 및 운영이 단순
- 특정 파티션의 메시지는 같은 소비자 그룹 안에서는 오직 한 소비자만 읽어갈 수 있으므로 리더 사본에 대한 연결은 많지 않음
- 아주 인기 있는 토픽이 아니라면 리더 사본에 대한 연결의 수는 그렇게 많지 않음
- 아주 인기 있는 토픽의 경우 파티션 및 소비자 수를 늘려 규모 확장 가능

어떤 사본이 ISR인지 아닌지 판단
-> 각 파티션 담당 리더는 자기 사본들이 어느 메시지까지 가져갔는지 추적하여 ISR 목록 관리

### 규모 확장성

- 생산자
  - 새로운 생산자를 추가하거나 삭제
- 소비자
  - 소비자 그룹은 서로 독립적, 새 소비자 그룹은 쉽게 추가 및 삭제 가능
  - 같은 소비자 그룹 내의 소비자가 새로 추가/삭제되거나 장애로 제거되어야 하는 경우 재조정 메커니즘이 맡아 처리
  - 소비자 측의 규모 확장성과 결함 내성을 보장하는 것 : 소비자 그룹 & 재조정 메커니즘
- 브로커
  - 가장 간단한 해법 : 브로커 노드가 추가되거나 삭제될 때 사본을 재배치
  - 더 나은 방법 : 브로커 컨트롤러로 하여금 한시적으로 시스템에 설정된 사본 수보다 많은 사본을 허용하도록 하는 것. 새로 추가된 브로커 노드가 기존 브로커 상태를 따라잡고 나면 더 이상 필요 없는 노드를 제거
- 파티션
  - 파티션 수 조정 시 생산자와 소비자의 안전성에는 영향 X
    - 생산자는 브로커와 통신할 때 그 사실을 통지 받음
    - 소비자는 재조정 시행
  - 파티션 수가 달리지면 데이터 저장 계층에 발생하는 일
    - 파티션 추가
      - 지속적으로 보관된 메시지는 여전히 기존 파티션에 존재, 이동 X
      - 새로운 파티션이 추가되면 그 이후 메시지는 파티션 전부에 지속적으로 보관
    - 파티션 제거
      - 새로운 메시지는 퇴역시키지 않을 파티션에만 보관
      - 퇴역된 파티션은 바로 제거하지 않고 일정 시간 동안 유지 (해당 파티션의 데이터를 읽고 있는 소비자가 있을 수 있기 대문, 해당 유지 기간이 지나고 데이터 삭제 후 저장 공간 반환)
      - 파티션 퇴역 후 실제로 제거가 이루어지는 시점까지 생산자는 메시지를 다른 파티션으로만 보내지만 소비자는 파티션 모두에서 메시지를 읽는다. 실제로 파티션이 제거되는 시점이 오면 소비자 그룹은 재조정 작업을 개시해야 한다.

### 메시지 전달 방식

#### At-most once, 최대 한 번

메시지 전달 과정에서 소실되더라고 다시 전달되는 일은 없다.

- 생산자는 토픽에 비동기적으로 메시지 보내고 수신 응답을 기다리지 않는다. (ACK=0)
- 소비자는 메시지를 읽고 처리하기전에 오프셋부터 갱신

지표 모니터링 등 소량의 데이터 손실은 감수할 수 있는 애플리케이션에 적합

#### At-least once, 최소 한 번

같은 메시지가 한 번 이상 전달될 수는 있으나 메시지 소실은 발생하지 않는 전달 방식

- 생산자는 메시지를 동기적/비동기적으로 보낼 수 있으며 ACK=1 또는 ACK=all 구성을 이용. 메시지가 브로커에게 전달되었음을 반드시 확인. 메시지 전달이 실패하거나 타임아웃이 발생하면 계속 재시도
- 소비자는 데이터를 성공적으로 처리한 뒤에만 오프셋을 갱신. 메시지 처리 실패한 경우 메시지를 다시 가져오므로 데이터가 손실되는 일은 없음. 메시지 중복 처리 발생 가능

메시지가 소실되는 일은 없지만 같은 메시지가 여러 번 전송될 수 있다.
데이터 중복이 큰 문제가 아닌 애플리케이션이나 소비자가 중복을 직접 제거할 수 있는 애플리케이션의 경우에는 충분히 괜찮은 전송 방식
(메시지마다 고유한 키가 있고 해당 키가 이미 데이터베이스에 있는 메시지는 처리하지 않고 버리거나..)

#### exactly once, 정확히 한 번

구현하기 가장 까다로운 전송 방식. 시스템의 성능 및 구현 복잡도 측면에서 큰 대가 지불 필요
지불, 매매, 회계 등 금융 관련 응용에는 이 전송 방식이 적합

### 메시지 필터링

메시지를 필터링하는 가장 쉬운 방법 : 소비자가 일단 모든 메시지를 받은 다음 필요 없는 메시지는 버리는 방법.
-> 유연성 높은 방법, 불필요한 트래픽 발생하여 시스템 성능 저하 가능

더 나은 방법 : 브로커에서 메시지를 필터링하여 소비자는 원하는 메시지만 받을 수 있도록 하는 것
메시지마다 태그를 두어 소비자는 어떤 태그를 가진 메시지를 구독할지 지정

### 메시지 지연 전송 및 예약 전송

발송 즉시 전달되는 메시지와는 달리 이런 메시지는 토픽에 바로 저장하지 않고 브로커 내부의 임시 저장소에 넣어 두었다가 시간이 되면 토픽으로 옮긴다.

- 하나 이상의 특별 메시지 토픽을 임시 저장소로 활용할 수 있다.

# 7장. 호텔 예약 시스템

## 기능 요구사항

- 호텔 정보 페이지 표시
- 객실 정보 페이지 표시
- 객실 예약 지원
- 호텔이나 객실 정보를 추가/삭제/갱신하는 관리자 페이지 지원
- 초과 예약 지원

## 비기능 요구사항

- 높은 수준의 동시성 : 성수기, 대규모 이벤트 기간에 높은 트래픽이 몰릴 수 있음
- 적절한 지연 시간 : 예약에 대한 응답 시간이 빠르며 이상적이지만 예약 요청 처리에 몇 초 정도 걸리는 것은 괜찮음

## 개략적 설계

### API 설계

RESTful

- 호텔 관련 API (GET, POST, PUT, DELETE)
- 객실 관련 API (GET, POST, PUT, DELETE)
- 예약 관련 API (GET, POST, PUT, DELETE)
  - 중복 예약 방지 및 예약이 1번만 된다는 보증을 위한 멱등 키 필요 (idempotent key)

```
{
"startDate" : "2021-04-28",
"endDate" : "2021-04-30",
"hotelID":"245",
"roomID":"U12345673389",
"reservationID":"13422445"
}
```

### 데이터 모델

호텔 예약 시스템이 지원해야 하는 질의

- 호텔 상세 정보 확인
- 지정된 날짜 범위에 사용 가능한 객실 유형 확인
- 예약 정보 기록
- 예약 내역 또는 과거 예약 이력 정보 조회

관계형 데이터베이스가 적합.

- 읽기 빈도가 쓰기 빈도에 비해 높은 작업 흐름을 잘 지원
  - 호텔 웹사이트/앱을 방문하는 사용자의 수가 실제로 객실을 예약하는 사용자 수에 비해 압도적으로 많음.
  - NoSQL 데이터베이스는 대체로 쓰기 연산에 최적화.
- ACID, 예약 시스템을 만드는 경우 중요
- 데이터를 쉽게 모델링
  - 비즈니스 데이터의 구조를 명확하게 표현 가능.
  - 엔티티들의 관계를 안정적으로 지원 가능

예약 테이블에는 status 필드가 필요

- pending, paid, refunded, canceled, rejected

5가지 상태로 결제 대기, 결제 완료, 환불 완료, 취소, 승인 실패 표현

### 개략적 설계안

MSA(Micro Service Architecture) 사용

공개 API 게이트웨이
-> 각 서비스별로 라우팅
-> 각 서비스별로 별도의 DB 소유

## 상세 설계

### 개선된 데이터 모델

호텔 객실 예약 시 특정 객실이 아닌 특정한 객실 유형을 예약하게 된다.
-> roomID가 아닌 roomTypeID 필요

객실 유형에 대한 인벤토리 테이블 필요 (room_type_inventory)

- hotel_id : 호텔 식별자
- room_type_id : 객실 유형 식별자
- date : 일자
- total_inventory : 예약 가능한 총 객실 수
- total_reserved : 예약된 객실 수

이 테이블의 기본 키 : (hotel_id, room_type_id, date)
-> 복합 키
가용 객실 데이터 질의 결과를 토대로 미리 데이터를 채워 놓고, 시간의 흐름에 띠라 새로 추가해야 하는 객실 정보는 매일 한 번씩 일괄 작업으로 돌려 반영

room_type_inventory 테이블은 고객이 특정 유형의 객실을 예약할 수 있는지 여부를 확인할 때 사용
-> 2번의 프로세스로 진행

1. 주어진 기간에 해당하는 레코드들 조회
2. 반환된 각 레코드마다 현재 예약 가능한지 검사

만약, 예약 데이터가 단일 데이터베이스에 담기 너무 크다면?

- 현재 및 향후 예약 데이터만 저장. 예약 이력은 자주 접근하지 않으므로 아카이빙 또는 냉동 저장소로 옮김
- 데이터베이스 샤딩. 가장 자주 사용되는 질의는 예약을 하거나 투숙객 이름으로 예약 확인 질의 -> 두 질의 모두 호텔을 알아야 하므로, hotel_id 기반 샤딩

### 동시성 문제

중복 예약 가능성이 존재하는 2개의 문제

1. 같은 사용자가 예약 버튼을 여러 번 누름
2. 여러 사용자가 같은 객실을 동시에 예약

#### 같은 사용자의 이중 클릭

- 클라이언트 측 구현 : 클라이언트 단에서 이중 클릭에 대한 문제 방지. 대부분의 이중 클릭 문제는 해결되지만 안정적이진 않다. 악의적인 사용자는 이를 우회할 수 있다
- 멱등(idempotent) API : 예약 API 요청에 멱등 키를 추가하는 방안. 몇 번을 호출해도 동일한 결과는 내는 API = 멱등 API.

#### 다른 사용자의 동시 예약

해결방법 : 락

- 비관적 락
- 낙관적 락
- 데이터베이스 제약 조건 (constraint)

객실 예약 프로세스

1. 잔여 객실 확인
2. 객실 예약

##### 비관적 락

비관적 락 : 비관적 동시성 제어 방안
사용자가 레코드를 갱신하려는 순간 즉시 락을 걸어 동시 업데이트를 방지하는 기술
해당 레코드를 갱신하려는 다른 사용자는 먼저 락을 건 사용자가 변경을 마치고 락을 해제할 때까지 기다려야 한다.
ex) MySQL SELECT ... FOR UPDATE

장점

- 애플리케이션이 변경 중이거나 변경이 끝난 데이터를 갱신하는 일을 막는다.
- 구현이 쉽고 모든 갱신 연산을 직렬화하여 충돌을 막는다. 비관적 락은 데이터에 대한 경합이 심할 때 유용하다.

단점

- 여러 레코드에 락을 걸면 교착 상태가 발생할 수 있다.
- 확장성이 낮다. 트랜잭션이 너무 오랫동안 락을 해제하지 않고 있으면 다른 트랜잭션은 락이 걸린 자원에 접근할 수 없다. -> 트랜잭션의 수명이 길거나 많은 엔티티에 관련된 경우 데이터베이스 성능에 심각한 영향을 끼친다.

##### 낙관적 락

낙관적 락 : 낙관적 동시성 제어 방안
-> 여러 사용자가 동시에 같은 자원을 갱신하려 시도하는 것을 허용

구현 방식

1. 버전 번호
2. 타임스탬프

타임스탬프의 경우 서버 시계가 시간이 지남에 따라 부정확해질 수 있으므로 일반적으로 버전 번호를 더 나은 선택지로 본다.

버전 번호 구현 방식

1. 데이터베이스 테이블에 version이라는 새 열을 추가
2. 애플리케이션의 해당 레코드의 버전 번호를 읽음
3. 사용자가 레코드를 갱신할 때 애플리케이션은 버전 번호에 1을 더한 다음 데이터베이스에 기록
4. 이때 유효성 검사 실시. 다음 버전 번호는 현재 버전 번호보다 1만큼 큰 값이어야만 한다. 유효성 검사가 실패하면 트랜잭션은 중단되고 사용자는 2번부터 다시 모든 절차를 반복한다.

낙관적 락은 일반적으로 비관적 락보다 빠르다.
: 데이터베이스에 락을 걸지 않기 때문.
하지만 동시성 수준이 아주 높으면 성능이 급격하게 나빠진다.
-> 결국 1개의 클라이언트만 갱신에 성공하기 때문 (지속적인 재시도 발생)

장점

- 애플리케이션이 유효하지 않은 데이터를 편집하는 일을 막는다.
- 데이터베이스 자원에 락을 걸 필요가 없다. 버전 번호를 통해 애플리케이션에서 데이터 일관성을 유지한다.
- 낙관적 락은 데이터에 대한 경쟁이 치열하지 않은 상황에 적합. 락을 관리하는 비용 없이 트랜잭션 실행 가능

단점

- 데이터에 대한 경쟁이 치열한 상황에서는 성능이 좋지 못하다

##### 데이터베이스 제약 조건 (constraint)

테이블 자체에 제약 조건 추가

장점

- 구현이 쉽다
- 데이터에 대한 경쟁이 심하지 않을 때 잘 동작

단점

- 낙관적 락과 마찬가지로 데이터에 대한 경쟁이 심하면 실패하는 연산 수가 엄청나게 늘어날 수 있다.
- 데이터베이스 제약 조건은 애플리케이션 코드와 달라서 버전 통제가 어려움
- 제약 조건을 허용하지 않는 데이터베이스도 존재. 데이터베이스를 다른 제품으로 교체 시 문제가 발생할 수 있음

### 시스템 규모 확장

#### 데이터베이스 샤딩

데이터베이스의 규모를 늘리는 한 가지 방법 : 샤딩
-> 데이터베이스를 여러 대 두고, 각각에 데이터의 일부만 보관하도록 하는 것

데이터베이스 샤딩 시 데이터를 어떻게 분배할지 정해야 함.
호텔 예약 시스템의 대부분 질의를 hotel_id를 필터링 조건으로 사용하기 때문에 해당 키를 샤딩 조건으로 쓰면 좋다는 결론에 도달 가능.

#### 캐시

호텔 잔여 객실 데이터는 오직 현재 그리고 미래 데이터만 중요함.
-> 고객이 과거의 어떤 객실을 예약하지 않기 때문

낡은 데이터는 자동적으로 소멸되도록 TTL을 설정할 수 있다면 바람직
-> Redis.

데이터 로딩 속도와 데이터베이스 확장성이 문제가 되기 시작하면 데이터베이스 앞에 캐시 계층을 두고 잔여 객실 확인 및 객실 예약 로직을 해당 계층에서 실행하도록 할 수 있음
하지만, 잔여 객실에 대한 최종적 진실을 데이터베이스에 있기 때문에 데이터베이스 확인 필수

##### 캐시가 주는 새로운 과제

캐시 계층 추가 시 시스템의 확장성과 처리량은 대폭 증가, 데이터베이스와 캐시 사이의 데이터 일관성 유지에 관한 새로운 도전에 직면하게 됨

잔여 객실 데이터에 대한 변화를 데이터베이스에 먼저 반영하므로 캐시에는 최신 데이터가 없을 가능성이 존재.
-> 이런 불일치는 데이터베이스가 최종적으로 잔여 객실 확인을 하도록 하면 문제가 되지 않음

장점

- 읽기 질의를 캐시가 처리하므로 데이터베이스의 부하가 크게 줄어듬
- 읽기 질의를 메모리에서 실행하므로 높은 성능을 보장할 수 있음

단점

- 데이터베이스와 캐시 사이의 데이터 일관성을 유지하는 것을 어려운 문제. 데이터 불일치가 사용자 경험에 미칠 영향을 신중하게 따져보아야 함

#### 서비스 간 데이터 일관성

MSA 구조로 인한 각 서비스 간 독자적인 DB
-> 데이터 일관성 문제 야기

해결 방법

- 2PC(2-Phase Commit) : 여러 노드에 걸친 원자적 트랜잭션 실행을 보증하는 데이터베이스 프로토콜. 모든 노드가 성공하든 아니면 실패하든 둘 중 하나로 트랜잭션이 마무리되도록 보증. blocking 실행이므로 한 노드에 장애 발생 시 해당 장애가 복구될 때까지 진행이 중단됨.
- SAGA : 각 노드에 국지적으로 발생하는 트랜잭션을 하나로 엮은 것. 각각의 트랜잭션은 완료되면 다음 트랜잭션을 시작하는 트리거로 쓰일 메시지를 만들어 보낸다. 어느 한 트랜잭션이라도 실패하면 사가는 그 이전 트랜잭션의 결과를 전부 되돌리는 트랜잭션들을 순차적으로 실행.
