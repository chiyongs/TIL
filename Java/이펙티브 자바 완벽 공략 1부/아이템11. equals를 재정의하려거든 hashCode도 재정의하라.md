# 아이템11. equals를 재정의하려거든 hashCode도 재정의하라

## hashCode 규약

equals 비교에 사용하는 정보가 변경 X → hashCode는 매번 같은 값을 리턴해야 함

두 객체에 대한 equals가 같다면 → hashCode도 같아야한다.

두 객체에 대한 equals가 다르다면 → hashCode 값이 같을 수 있지만 해시 테이블 성능을 고려해 다른 값을 리턴하는 것이 좋다.

hashCode를 구현할 때에는 equals 구현 시 사용한 모든 필드들을 사용해야 한다.

> HashMap에 넣을 때와 꺼낼 때로 hashCode 구현의 필요성을 알 수 있다.

HashMap에 객체를 넣는 과정에서 hashCode 메서드를 실행하여 어느 bucket에 넣을지 결정한다.

꺼낼 때도 hashCode 값을 먼저 가져와서 해당 값에 해당하는 객체를 꺼낸다.

다른 두 객체가 같은 hashCode를 가질 수 있다.
그런 경우에 HashMap도 정상적으로 작동한다.
하지만, 이런 경우 HashMap을 사용하는 의미가 줄어든다. HashMap의 hash를 사용하여 탐색 시에 O(1)의 좋은 효율을 보여주지만, 다른 객체가 같은 hash 값을 가지게 된다면 그것은 List를 사용하는 것과 같이 O(n)이 되버리기 때문이다.

## hashCode 구현 방법

```java
@Overrie
public int hashCode() {
	int result = Short.hashCode(firstImportantField); // 1
	result = 31 * result + Short.hashCode(secondImportantField); // 2
	result = 31 * result + Short.hashCode(thirdImportantField); // 3
	return result;
}
```

1. 핵심 필드 중 하나의 값의 해시값을 계산한다.
   1. 만약, 해당 값이 primitive type이면 wrapper type의 hashCode 메소드를 사용해서 해시값을 구하면 된다.
   2. primitive type이 아닌 경우, 해당 Reference가 가지고 있는 hashCode 메소드를 사용한다.
2. 그 후 첫 핵심 필드의 해시값에 특정 숫자를 곱하고 다른 핵심 필드의 해시값을 더하는 과정을 반복한다.
