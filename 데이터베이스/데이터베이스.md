# 데이터베이스의 기본

- 데이터베이스 : 일정한 규칙 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음
- 실시간 접근과 공유 가능
- 엔티티 : 사람, 장소, 물건, 사건 개념 등 여러 개의 속성을 지닌 명사를 의미
- 릴레이션 : 데이터베이스에서 정보를 구분하여 저장하는 기본 단위
  - 관계형 데이터베이스 : 테이블
  - NoSQL 데이터베이스 : 컬렉션
- 속성 : 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보
- 도메인 : 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합

## 정규화

- 정규화 과정은 릴레이션 간의 잘못된 종속 관계로 인해 데이터베이스 이상 현상을 해결하거나, 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정
- 이상현상은 테이블을 설계할 때 잘못 설계하여 데이터의 삽입, 삭제, 수정 시 생기는 논리적 오류를 말합니다.
- 삽입 이상 : 자료를 삽입할 때 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 현상입니다.
- 갱신 이상 : 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상입니다.
- 삭제 이상 : 어떤 정보를 삭제하면, 의도하지 않은 다른 정보까지 삭제되어버리는 현상입니다.
- 이러한 이상 현상을 예방하고 효과적인 연산을 하기위해 데이터 정규화를 합니다.
- 정규화의 원칙
  - 자료의 중복성은 감소해야 하고 독립적인 관계는 별개이 릴레이션으로 표현해야 하며, 각각의 릴레이션은 독립적인 표현이 가능해야 함
- 제1 정규형 : 테이블의 컬럼이 원자 값을 가지도록 분해합니다.
- 제2 정규형 : 제1 정규형을 만족하고 기본키가 아닌 속성이 기본키에 완전 함수 종속이도록 분해합니다.
  - 완전 함수 종속 : 기본키의 부분집합이 다른 값을 결정하지 않는 것을 의미
- 제3 정규형 : 제2 정규형을 만족하고 이행적 함수 종속을 없애도록 분해합니다.
  - 이행적 함수 종속 : A→B, B→C가 성립할 때 A→C가 성립되는 것을 의미
- BCNF 정규형 : 제3 정규형을 만족하고, 함수 종속성 X→Y가 성립할 때 모든 결정자 X가 후보키가 되도록 분해합니다.

- 정규화 장점
  - 데이터베이스 구조 확장 시 정규화된 데이터베이스는 변경하지 않아도 되거나 일부만 변경하면 됩니다.
  - 이상현상이 발생하는 문제점을 해결할 수 있습니다.
- 정규화 단점
  - 릴레이션의 분해로 인해 JOIN연산이 많아집니다. 이로인해 질의에 대한 응답시간이 느려질 수 있습니다.

# 트랜잭션과 무결성

## 트랜잭션

- 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
- 여러 개의 쿼리들을 하나로 묶는 단위

### 원자성 Atomicity

- 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징

> 커밋과 롤백

- 커밋 : 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
  - 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장되는 것을 말함
- 롤백 : 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일

이런 커밋과 롤백으로 데이터의 무결성이 보장됨

### 일관성 Consistency

- 허용된 방식으로만 데이터를 변경해야 하는 것을 의미
- 데이터베이스에 기록된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야 함

### 격리성 Isolation

- 트랜잭션 수행 시 서로 끼어들지 못하는 것
- 복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야 함 & 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야 함

> 트랜잭션 격리 수준

- Serializable : 트랜잭션을 순차적으로 진행시키는 것
  - 여러 트랜잭션이 동시에 같은 행에 접근할 수 없음
  - 매우 엄격한 수준, 교착 상태가 일어날 확률이 높으며 가장 성능이 떨어짐
- Repeatable Read : 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행을 추가하는 것을 막지 않음 → 이후에 추가된 행이 발견될 수 있음
  - Phantom read : 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우
- Read commited : 커밋이 완료된 데이터에 대해서만 조회를 허용, 커밋되지 않는 정보는 읽을 수 없음
  - 가장 많이 사용되는 격리 수준
  - Non-repeatable read : 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데 그 값이 다른 경우
- Read uncommited : 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠르고 가장 낮은 수준의 격리 수준

### 지속성 Durability

- 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것을 의미
- 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복기능이 있어야 함을 뜻함

## 무결성

- 데이터의 정확성, 일관성, 유효성을 유지하는 것
- 무결성이 유지되어야 데이터에 대한 신뢰가 생김

# 인덱스

## 인덱스의 필요성

- 인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치
- 인덱스를 설정하면 테이블 안에 내가 찾고자 하는 데이터를 빠르게 찾을 수 있음

## B-트리

- 인덱스는 보통 B-트리 자료구조로 이루어져 있다.
- B-트리는 루트 노드, 브랜치 노드, 리프노드로 나뉜다.
- 트리 탐색은 맨 위 루트 노드부터 브랜치 노드를 거쳐 리프 노드까지 내려간다.

### 인덱스가 효율적인 이유와 대수확장성

- 인덱스가 효율적인 이유 : 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성
  - 대수확장성 : 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것
  - 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가

## 인덱스 만드는 방법

- MySQL의 경우
- 인덱스 : 클러스터형 인덱스와 세컨더리 인덱스
- primary key, unique not null → 클러스터형 인덱스
- create index … → 세컨더리 인덱스
- 하나의 인덱스만 생성한다면 클러스터형 인덱스가 성능이 좋음
- 세컨더리 인덱스는 보조 인덱스 → 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스

## 인덱스 최적화 기법

### 인덱스는 비용

- 인덱스는 두 번 탐색하도록 강요
  - 인덱스 리스트, 테이블 순으로 탐색 → 읽기 비용이 많이 듬
- 테이블이 수정되었을 때 인덱스도 수정되어야 함
- B-트리의 높이를 균형 있게 조절하는 비용
- 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용
- 따라서 테이블에서 가져와야 하는 양이 많을 수록 인덱스를 사용하는 것은 비효율적

### 항상 테스팅

- 인덱스 최적화 기법은 서비스의 특징에 따라 달라짐
- 따라서, 쿼리를 보낸 후 테스팅해야 함
- explain 함수를 통해 테스팅 가능

### 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순

- 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 생성 → 이때 인덱스를 생성하는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라짐

1. 어떠한 값과 같음을 비교하는 쿼리가 있다면 가장 먼저 인덱스로 설정
2. 정렬에 사용하는 필드면 그 다음 인덱스로 설정
3. 다중 값을 출력해야 하는 필드, 쿼리 자체가 > 이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드면 나중에 인덱스 설정
4. 카디널리티가 높은 순서를 기반으로 인덱스 설정

# 조인의 종류

- 조인 : 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것
- 내부 조인(inner join) : 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기
- 왼쪽 조인(left outer join) : 왼쪽 테이블의 모든 행이 결과 테이블에 표기
- 오른쪽 조인(right outer join) : 오른쪽 테이블의 모든 행이 결과 테이블에 표기
- 합집합 조인(full outer join) : 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기

### 내부 조인

- 두 테이블 간의 교집합을 나타냄

### 왼쪽 조인

- 테이블 B의 일치하는 부분의 레코드와 함께 테이블 A를 기준으로 완전한 레코드 집합을 생성
- 테이블 B에 일치하는 항목이 없으면 null 값이 됨

### 오른쪽 조인

- 테이블 A의 일치하는 부분의 레코드와 함께 테이블 B를 기준으로 완전한 레코드 집합을 생성
- 테이블 A에 일치하는 항목이 없으면 null 값이 됨

### 합집합 조인

- 양쪽 테이블에서 일치하는 레코드와 함께 테이블 A와 테이블 B의 모든 레코드 집합을 생성
- 누락된 값이 null

# 조인의 원리

- 중첩 루프 조인 : 중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법
  - 랜덤 접근에 대한 비용이 많이 증가 → 대용량의 테이블에서는 사용하지 않음
- 정렬 병합 조인 : 각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인
  - 조인할 때 쓸 적절한 인덱스가 없고 대용량의 테이블을 조인하고 조인 조건으로 범위 비교 연산자가 있을 때 사용
- 해시 조인 : 해시 테이블을 기반으로 조인하는 방법
  - 하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적
  - 메모리에 올릴 수 없을 정도로 크다면 디스크를 사용하는 비용 발생
  - 동등 조인에서만 사용 가능
