# 4장. 분산 메시지 큐

분산 메시지 큐 사용 시 이점

- 결합도 완화 : 강결합 사라짐
- 규모 확장성 개선 : 생산자와 소비자가 독립적
- 가용성 개선 : 개별 컴포넌트의 장애와 상관없이 다른 컴포넌트는 큐와 상호작용
- 성능 개선 : 비동기 통신 가능

## 기능 요구사항

- 생산자는 메시지 큐에 메시지를 보낼 수 있어야 한다.
- 소비자는 메시지 큐를 통해 메시지를 수신할 수 있어야 한다.
- 메시지는 반복적으로 수신 or 단 한 번만 수신하도록 설정
- 오래된 이력 데이터 삭제될 수 있다.
- 메시지 크기는 킬로바이트 수준
- 메시지는 생산된 순서대로 소비자에게 전달
- 메시지 전달 방식은 최소 한 번, 최대 한 번, 정확히 한 번 가운데 설정할 수 있어야 한다.

## 비기능 요구사항

- 높은 대역폭과 낮은 전송 지연 가운데 하나를 설정할 수 있어야 하는 기능
- 규모 확장성, 메시지 양이 급증해도 처리 가능해야 함
- 지속성 및 내구성, 데이터는 디스크에 지속적으로 보관 & 여러 노드에 복제되어야 함

### 전통적 메시지 큐와 다른 점

전통적 메시지 큐 : 메시지 보관 문제 중요 X
-> 메시지가 소비자에게 전달되기 충분한 기간동안만 메모리에 보관
메시지 전달 순서도 보존 X
-> 생산된 순서와 소비되는 순서 다를 수 있음

## 메시지 모델

### 일대일 (point to point)

- 전통적인 메시지 큐에서 흔히 발견되는 모델
- 오직 한 소비자만 메시지를 소비
- 데이터 보관 (Data Retention) 지원 X

과정

1. 소비지가 메시지 가져감
2. 소비자가 큐에 알림 (Acknowledge)
3. 메시지 큐에서 삭제

### 발행-구독 (publish-subscribe)

토픽 : 메시지를 주제별로 정리하는 데 사용
각 토픽은 메시지 큐 서비스 전반에 고유한 이름을 가짐

토픽에 전달된 메시지는 해당 토픽을 구독하는 모든 소비자에게 전달

#### 토픽, 파티션, 브로커

토픽에 보관되는 데이터의 양이 커져서 서버 한 대로 감당이 어려움
-> 파티션 사용으로 해결 가능
토픽을 여러 파티션으로 분할한 다음, 메시지를 모든 파티션에 균등하게 나눠 보냄
-> 파티션 : 토픽에 보낼 메시지의 작은 부분 집합

파티션은 메시지 큐 클러스터 내의 서버에 고르게 분산 배치함
파티션을 유지하는 서버 -> 브로커
파티션을 브로커에 분산하는 것이 높은 규모 확장성을 달성하는 비결
토픽의 용량을 확장하고 싶으면 파티션 개수를 늘리면 됨

각 토픽 파티션은 FIFO로 동작
-> 같은 파티션 안에서는 메시지 순서가 유지됨

생산자가 보낸 메시지는 해당 토픽의 파티션 중 하나로 보내짐

- 같은 키를 가진 모든 메시지는 같은 파티션으로 보내짐
- 키가 없는 메시지는 랜덤한 파티션으로 보내짐

토픽을 구독하는 소비자는 하나 이상의 파티션에서 데이터를 가져오게 된다.
-> 소비자가 파티션보다 많으면 유휴 소비자 발생 가능

#### 소비자 그룹

하나의 소비자 그룹은 여러 토픽 구독 & 오프셋을 별도로 관리
같은 그룹 내의 소비자는 메시지를 병렬로 소비 가능
-> 병렬로 소비 시 대역폭 좋음, 하지만 같은 파티션 안에 있는 메시지를 순서대로 소비 불가능
-> 소비 순서 보장 불가능

소비 순서 보장 방법
: 어떤 파티션의 메시지는 한 그룹 안에서는 오직 한 소비자만 읽을 수 있도록 강제
-> 그룹 내 소비자 수가 구독하는 토픽의 파티션 수보다 많으면 유휴 소비자 발생

## 개략적 설계안

클라이언트

- 생산자 : 메시지를 특정 토픽으로 보낸다
- 소비자 그룹 : 토픽을 구독하고 메시지를 소비한다

핵심 서비스 및 저장소

- 브로커 : 파티션들을 유지, 하나의 파티션은 특정 토픽에 대한 메시지의 부분 집합을 유지
- 데이터 저장소 : 메시지는 파티션 내 데이터 저장소에 보관
- 상태 저장소 : 소비자 상태 저장
- 메타데이터 저장소 : 토픽 설정, 토픽 속성 등 저장
- 조정 서비스
  - 서비스 탐색 (Service Discovery) : 어느 브로커가 살아있는지
  - 리더 선출 : 브로커 가운데 하나는 컨트롤러 역할을 담당. 한 클러스터에는 반드시 활성 상태의 컨트롤러가 1개는 존재해야함. 파티션 배치를 책임

## 상세 설계

데이터 장기 보관 및 높은 대역폭 제공을 위한 3가지 결정

- 디스크 기반 자료구조 활용
- 메시지가 생산자 -> 소비자에게 전달되는 순간까지 아무 수정 없이 전송 가능한 메시지 자료구조
- 일괄 처리를 우선하는 시스템 설계, 소규모 I/O 많으면 높은 대역폭 지원 어려움.
  생산자는 메시지 일괄 전송, 메시지 큐는 그 메시지들을 더 큰 단위로 묶어 보관, 소비자도 가능하면 메시지 일괄 수신

### 데이터 저장소

메시지 큐의 트래픽 패턴

- 읽기와 쓰기가 빈번하게 발생
- 갱신/삭제 연산은 발생 X
- 순차적인 읽기/쓰기가 대부분

WAL (Write Ahead Log), 쓰기 우선 로그
: 새로운 항목이 추가되기만 하는 append-only 일반 파일
MySQL의 복구 로그 (redo log), 아파치 주키퍼에서도 활용

지속성을 보장해야 하는 메시지는 디스크에 WAL로 보관할 것을 추천
WAL의 접근 패턴 : 읽기/쓰기 전부 순차적
-> 접근 패턴이 순차적일때 디스크는 아주 좋은 성능을 보임

새로운 메시지는 파티션 꼬리 부분에 추가, 오프셋은 그 결과로 점진적으로 증가
세그먼트 단위로 관리.
비활성 세그먼트 파일은 보관 기한이 만료되거나 용량 한계에 도달하면 삭제

#### 디스크 성능 관련 유의사항

데이터 장기 보관에 대한 요구사항으로 인해 디스크 드라이브 활용하여 대량의 데이터 보관
회전식 디스크가 느린 것은 데이터 접근 패턴이 무작위일 때.
메시지 큐에서는 데이터 접근 패턴이 순차적이므로 충분히 적합한 성능 발휘.

현대적 운영체제는 디스크 데이터를 메모리에 아주 적극적으로 캐시
-> WAL도 OS가 제공하는 디스크 캐시 기능을 적극적으로 활용

### 메시지 자료 구조

메시지 자료구조는 높은 대역폭 달성의 열쇠
메시지가 큐를 거쳐 소비자에게 전달되는 과정에서 불필요한 복사가 일어나지 않도록 해야 높은 대역폭 달성 가능

필드 이름 : 데이터 자료형

- key : byte[]
- value : byte[]
- topic : string
- partition : integer
- offset : long
- timestamp : long
- size : integer
- crc : integer

#### 메시지 키

파티션을 정할 때 사용

- 키가 주어지지 않은 메시지는 파티션이 무작위로 결정
- 키가 주어진 메시지는 파티션이 hash(key) % numPartitions 공식에 따라 결정

더 유연한 설계가 필요하다면 생산자는 직접 파티션 선정 메커니즘을 정의 가능

키에는 비즈니스 관련 정보가 담기는 것이 보통

#### 메시지 값

메시지의 내용, 즉 payload

#### 메시지의 기타 필드

- 토픽 : 메시지가 속한 토픽의 이름
- 파티션 : 메시지가 속한 파티션의 ID
- 오프셋 : 파티션 내의 메시지의 위치. 메시지는 토픽, 파티션, 오프셋 세 가지 정보를 알면 찾을 수 있다.
- 타임스탬프 : 메시지가 저장된 시각
- 크기 : 메시지의 크기
- CRC : 순환 중복 검사, 주어진 데이터의 무결성을 보장하는데 이용

### 일괄 처리

일괄처리 : 시스템 성능에 아주 중요

이유

- 운영체제로 하여금 여러 메시지를 한 번의 네트워크 요청으로 전송할 수 있도록 하기 때문에 값비싼 네트워크 왕복 비용 제거 가능
- 브로커가 여러 메시지를 한 번에 로그에 기록하면 더 큰 규모의 순차 쓰기 연산이 발생 -> 디스크 캐시에서 더 큰 규모의 연속된 공간을 점유 가능

높은 대역폭과 낮은 응답 지연은 동시에 달성하기 어려운 목표
시스템이 낮은 응답 지연이 중요한 전툥적 메시지 큐로 이용된다면 일괄 처리 메시지 양은 낮춘다.
-> 디스크 성능은 다소 낮아진다

처리량을 높여야 한다면 토픽당 파티션의 수를 늘린다
-> 낮아진 순차 쓰기 연산 대역폭을 발충할 수 있다

### 생산자 측 작업 흐름

생산자가 어떤 파티션에 메시지를 보내야할 때 어느 브로커에 연결해야 할까?
-> 해결책 : 라우팅 계층
라우팅 계층이 적절한 브로커에 메시지를 보내는 역할을 담당
메시지를 받을 적절한 브로커 : 리더 브로커

생산자 내부에 라우팅 계층을 두고 버퍼를 도입
생산자 클라이언트 라이브러리의 일부로 생산자에 설치
-> 생산자에서 라우팅 계층으로의 네트워크를 거칠 필요가 없으므로 전송 지연 감소
-> 생산자는 메시지를 어느 파티션에 보낼지 결정하는 자신만의 로직을 가질 수 있음
-> 저송할 메시지를 버퍼 메모리에 보관했다가 목적지로 일괄 전송하여 대역폭을 높일 수 있음

- 일괄 처리 메시지의 양을 늘리면 대역폭 증가 but 응답 속도 느려짐
  :일괄 처리가 가능할 양의 메시지를 기다려야 함
- 양을 줄이면 메시지는 더 빨리 보낼 수 있으니 지연은 줄어들지만 대역폭 손해

생산자는 메시지 큐의 용도를 감안하여 일괄 처리 메시지 양을 조정해야 함

### 소비자 측 작업 흐름

소비자는 특정 파티션의 오프셋을 주고 해당 위치에서부터 이벤트를 묶어 가져온다

#### 푸쉬 vs 풀

푸쉬 모델

- 장점
  - 낮은 지연 : 브로커는 메시지를 받는 즉시 소비자에게 보낼 수 있다.
- 단점
  - 소비자의 메시지 처리 속도보다 생신자의 메시지 생산 속도가 빠를 경우, 소비자에게 큰 부하 발생
  - 생산자가 데이터 전송 속도를 좌우하므로, 소비자의 컴퓨팅 자원은 생산자에 의존적으로 준비 필요

풀 모델

- 장점
  - 메시지 소비 속도를 소비자가 알아서 결정
  - 메시지 소비 속도가 생산 속도보다 느려지면 소비자를 늘려 해결하거나 생산 속도를 따라잡을 때까지 기다릴 수도 있음
  - 일괄 처리에 적합. 소비자가 지난번 마지막으로 가져간 로그 위치 다음에 오는 모든 메시지를 한 번에 가져갈 수 있음. 공격적 일괄 처리에 좀 더 적합
- 단점
  - 브로커에 메시지가 없어도 소비자는 계속 데이터를 끌어가려 시도, 소비자 측 컴퓨팅 자원이 낭비됨. 롱 폴링 모드로 극복 (당장은 가져갈 메시지가 없더라도 일정 시간은 기다리도록 하는 것)

동작 흐름

1. 토픽 구독을 원하는 새로운 소비자 등장. 그룹 이름을 해싱하여 접속할 브로커 노드를 찾음. 같은 그룹의 모든 소비자는 같은 브로커에 접속. 해당 브로커는 해당 소비자 그룹의 코디네이터. 코디네이터는 소비자 그룹의 조정 작업만 담당
2. 코디네이터는 해당 소비자를 그룹에 참여시키고 해당 소비자에게 파티션을 할당
3. 소비자는 마지막으로 소비한 오프셋 이후 메시지를 가져온다. 오프셋 정보는 상태 저장소에 존재
4. 소비자는 메시지를 처리하고 새로운 오프셋을 브로커에 보낸다. 데이터 처리와 오프셋 갱신 순서는 메시지 전송 시맨틱에 영향을 미침

### 소비자 재조정

어떤 소비자가 어떤 파티션을 책임지는지 다시 정하는 프로세스

- 새로운 소비자의 합류
- 기존 소비자의 이탈
- 특정 소비자의 장애 발생
- 파티션 조정
  위 경우에 소비자 재조정 프로세스 시작

소비자 재조정에는 코디네이터가 중요한 역할을 함
코디네이터 : 소비자 재조정을 위해 소비자들과 통신하는 브로커 노드
소비자로부터 오는 하트비트 메시지를 살피고 각 소비자의 파티션 내 오프셋 정보를 관리

- 같은 그룹의 모든 소비자는 같은 코디네이터에 연결
- 코디네이터는 자신에 연결한 소비자 목록을 유지. 이 목록에 변화가 생기면 코디네이터는 해당 그룹의 새 리더를 선출
- 새 리더는 새 파티션 배치 계획을 만들고 코디네이터에게 전달. 코디네이터는 해당 계획을 그룹 내 다른 모든 소비자에게 알림

소비자 장애 감지 시 코디네이터는 재조정 프로세스를 시작하여 파티션을 재배치함

#### 재조정 시나리오

코디네이터는 소비자 재조정이 필요할 시 모든 소비자에게 그 사실을 수동적으로 통지
-> 소비자의 하트비트 메시지가 왔을 때 그 응답으로 그룹에 다시 합류하라고 알림

모든 소비자의 그룹 합류 이후 리더 선출, 그룹 동기화 요청, 리더로부터 받은 파티션 배치 계획 전파

### 상태 저장소

- 소비자에 대한 파티션의 배치 관계
- 각 소비자 그룹이 각 파티션에서 마지막으로 가져간 메시지의 오프셋
  를 저장한다.

소비자 상태 정보 데이터가 이용되는 패턴

- 읽기와 쓰기가 빈번하게 발생, 양은 많지 않음
- 데이터 갱신은 빈번하게 일어나지만 삭제되는 일은 거의 없음
- 읽기와 쓰기 연산은 무작위적 패턴
- 데이터의 일관성이 중요

-> 아파치 주키퍼와 같은 키-값 저장소 사용이 바람직

### 메타데이터 저장소

토픽 설정이나 속성 정보를 보관
(파티션 수, 메시지 보관 기간, 사본 배치 정보 등)

메타데이터는 자주 변경되지 않으며 양도 적다. 하지만 높은 일관성을 요구
-> 주키퍼가 적절

#### 주키퍼

계층적 키-값 저장소
-> 분산 시스템에 필수적인 서비스

- 메타데이터와 상태 저장소는 주키퍼를 이용해 구현
- 브로커는 이제 메시지 데이터 저장소만 유지
- 주키퍼가 브로커 클러스터의 리더 선출 과정을 돕는다

### 복제

분산 시스템에서 하드웨어 장애는 흔한 일, 디스크에 손상이나 영구적 장애 발생 시 데이터 유실
-> 높은 가용성 보장을 위해 복제 사용

사본들은 서로 다른 브로커 노드에 분산
생산자는 파티션에 메시지를 보낼 때 리더에게만 보냄
다른 사본은 리더에서 새 메시지를 지속적으로 가져와 동기화
메시지를 완전히 동기화한 사본의 개수가 지정된 임계값을 넘으면 리더는 생산자에게 메시지를 잘 받았다는 응답을 보냄

사본 분산 계획 : 사본을 파티션에 어떻게 분산할지 기술하는 것
-> 조정 서비스의 도움으로 브로커 노드 중 하나가 리더로 선출되면 해당 리더 브로커 노드가 사본 분산 계획을 만들고 메타데이터 저장소에 보관

#### 사본 동기화

어떤 한 노드의 장애로 메시지가 소실되는 것을 막기 우해 메시지는 여러 파티션에 두며 각 파티션은 다시 여러 사본으로 복제
-> 문제는 그 모두를 어떻게 동기화시킬 것인지
동기화된 사본 : In-Sync Replicas, ISR은 리더와 동기화된 사본

리더와 사본의 합의된 오프셋까지 동기화되었다면 해당 사본은 ISR.
ISR이 필요한 이유 : 성능과 영속성 사이의 타협점
생산자가 보낸 어떤 메시지도 소실하지 않는 가장 안전한 방법
: 생산자에게 메시지를 잘 받았다는 응답을 보내기 전에 모든 사본을 동기화하는 것
-> 어느 사본 하나라도 동기화를 신속하게 처리하지 못한다면 파티션 전부가 느려지거나 아예 못 쓰게 되는 일 발생

#### ACK=all

생산자는 모든 ISR이 메시지를 수신한 뒤에 ACK 응답을 받는다.
느린 ISR의 응답을 기다려야 하므로 메시지를 보내기 위한 시간이 길어진다.
메시지의 영속성 측면에서는 가장 좋은 구성

#### ACK=1

생산자는 리더가 메시지를 저장하고 나면 바로 ACK 응답을 받는다
데이터가 동기화될 때까지 기다리지 않아서 응답 지연은 개선된다.
메시지 ACK를 보낸 직후 리더에 장애가 생기면 해당 메시지는 다른 사본에 반영되지 못했으므로 영구 소실됨
데이터가 사라져도 상관없는 대신 낮은 응답 지연을 보장해야 하는 시스템에 적합

#### ACK=0

생산자는 보낸 메시지에 대한 수신 확인 메시지를 기다리지 않고 계속 메시지 전송하며 어떤 재시도도 하지 않음
지표 수집이나 데이터 로깅 등 처리해야 하는 메시지의 양이 많고 때로 데이터 손실이 발생해도 상관 없는 경우에 좋다.

ACK 설정이 변경 가능하면 성능을 높여야 할 경우 영속성을 다소 희생할 수도 있다.

소비자 측에서는 가장 쉬운 구성은 소비자로 하여금 리더에게 메시지를 읽어가도록 하는 것

리더 사본에 요청이 너무 몰리거나 ISR 요건을 만족하는 사본에서 메시지를 가져가지 않는 이유

- 설계 및 운영이 단순
- 특정 파티션의 메시지는 같은 소비자 그룹 안에서는 오직 한 소비자만 읽어갈 수 있으므로 리더 사본에 대한 연결은 많지 않음
- 아주 인기 있는 토픽이 아니라면 리더 사본에 대한 연결의 수는 그렇게 많지 않음
- 아주 인기 있는 토픽의 경우 파티션 및 소비자 수를 늘려 규모 확장 가능

어떤 사본이 ISR인지 아닌지 판단
-> 각 파티션 담당 리더는 자기 사본들이 어느 메시지까지 가져갔는지 추적하여 ISR 목록 관리

### 규모 확장성

- 생산자
  - 새로운 생산자를 추가하거나 삭제
- 소비자
  - 소비자 그룹은 서로 독립적, 새 소비자 그룹은 쉽게 추가 및 삭제 가능
  - 같은 소비자 그룹 내의 소비자가 새로 추가/삭제되거나 장애로 제거되어야 하는 경우 재조정 메커니즘이 맡아 처리
  - 소비자 측의 규모 확장성과 결함 내성을 보장하는 것 : 소비자 그룹 & 재조정 메커니즘
- 브로커
  - 가장 간단한 해법 : 브로커 노드가 추가되거나 삭제될 때 사본을 재배치
  - 더 나은 방법 : 브로커 컨트롤러로 하여금 한시적으로 시스템에 설정된 사본 수보다 많은 사본을 허용하도록 하는 것. 새로 추가된 브로커 노드가 기존 브로커 상태를 따라잡고 나면 더 이상 필요 없는 노드를 제거
- 파티션
  - 파티션 수 조정 시 생산자와 소비자의 안전성에는 영향 X
    - 생산자는 브로커와 통신할 때 그 사실을 통지 받음
    - 소비자는 재조정 시행
  - 파티션 수가 달리지면 데이터 저장 계층에 발생하는 일
    - 파티션 추가
      - 지속적으로 보관된 메시지는 여전히 기존 파티션에 존재, 이동 X
      - 새로운 파티션이 추가되면 그 이후 메시지는 파티션 전부에 지속적으로 보관
    - 파티션 제거
      - 새로운 메시지는 퇴역시키지 않을 파티션에만 보관
      - 퇴역된 파티션은 바로 제거하지 않고 일정 시간 동안 유지 (해당 파티션의 데이터를 읽고 있는 소비자가 있을 수 있기 대문, 해당 유지 기간이 지나고 데이터 삭제 후 저장 공간 반환)
      - 파티션 퇴역 후 실제로 제거가 이루어지는 시점까지 생산자는 메시지를 다른 파티션으로만 보내지만 소비자는 파티션 모두에서 메시지를 읽는다. 실제로 파티션이 제거되는 시점이 오면 소비자 그룹은 재조정 작업을 개시해야 한다.

### 메시지 전달 방식

#### At-most once, 최대 한 번

메시지 전달 과정에서 소실되더라고 다시 전달되는 일은 없다.

- 생산자는 토픽에 비동기적으로 메시지 보내고 수신 응답을 기다리지 않는다. (ACK=0)
- 소비자는 메시지를 읽고 처리하기전에 오프셋부터 갱신

지표 모니터링 등 소량의 데이터 손실은 감수할 수 있는 애플리케이션에 적합

#### At-least once, 최소 한 번

같은 메시지가 한 번 이상 전달될 수는 있으나 메시지 소실은 발생하지 않는 전달 방식

- 생산자는 메시지를 동기적/비동기적으로 보낼 수 있으며 ACK=1 또는 ACK=all 구성을 이용. 메시지가 브로커에게 전달되었음을 반드시 확인. 메시지 전달이 실패하거나 타임아웃이 발생하면 계속 재시도
- 소비자는 데이터를 성공적으로 처리한 뒤에만 오프셋을 갱신. 메시지 처리 실패한 경우 메시지를 다시 가져오므로 데이터가 손실되는 일은 없음. 메시지 중복 처리 발생 가능

메시지가 소실되는 일은 없지만 같은 메시지가 여러 번 전송될 수 있다.
데이터 중복이 큰 문제가 아닌 애플리케이션이나 소비자가 중복을 직접 제거할 수 있는 애플리케이션의 경우에는 충분히 괜찮은 전송 방식
(메시지마다 고유한 키가 있고 해당 키가 이미 데이터베이스에 있는 메시지는 처리하지 않고 버리거나..)

#### exactly once, 정확히 한 번

구현하기 가장 까다로운 전송 방식. 시스템의 성능 및 구현 복잡도 측면에서 큰 대가 지불 필요
지불, 매매, 회계 등 금융 관련 응용에는 이 전송 방식이 적합

### 메시지 필터링

메시지를 필터링하는 가장 쉬운 방법 : 소비자가 일단 모든 메시지를 받은 다음 필요 없는 메시지는 버리는 방법.
-> 유연성 높은 방법, 불필요한 트래픽 발생하여 시스템 성능 저하 가능

더 나은 방법 : 브로커에서 메시지를 필터링하여 소비자는 원하는 메시지만 받을 수 있도록 하는 것
메시지마다 태그를 두어 소비자는 어떤 태그를 가진 메시지를 구독할지 지정

### 메시지 지연 전송 및 예약 전송

발송 즉시 전달되는 메시지와는 달리 이런 메시지는 토픽에 바로 저장하지 않고 브로커 내부의 임시 저장소에 넣어 두었다가 시간이 되면 토픽으로 옮긴다.

- 하나 이상의 특별 메시지 토픽을 임시 저장소로 활용할 수 있다.
