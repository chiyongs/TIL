# 아이템13. clone 재정의는 주의해서 진행하라

## Clone 규약

clone : 오브젝트를 그대로 복사하는 기능

Clone을 만드려면 Cloenable 인터페이스를 꼭 구현해야 하고 clone 메소드를 재정의해야 한다.

Cloneable 인터페이스는 마커 인터페이스처럼 속이 비어있지만, clone을 사용하기 위해서는 꼭 구현해야 함.

1. clone은 반드시 원본과 다른 인스턴스여야 한다.
   1. x.clone ≠ x → 반드시 참이여야 한다. (논리적 동치성은 같을 수 있겠지만, 레퍼런스 자체가 다른 오브젝트를 참조해야 함)
2. clone해서 만들어진 오브젝트의 클래스와 원본의 클래스가 같아야 한다.
   1. x.clone().getClass() == x.getClass() → 반드시 참
3. x.clone().eqauls(x) 가 true가 아닐 수도 있다.

clone 메소드를 사용해서 만들어지는 인스턴스는 생성자를 사용해서 만들어지지 않는다.

## 가변 객체의 clone을 정의하는 방법

1. 접근 제한자는 public, 반환타입은 자기 자신 클래스로 변경한다.
2. super.clone을 호출하고 필요한 필드를 적절히 수정한다.

주의할 점

- 배열을 가지고 있는 경우 배열도 clone 해줘야 한다.
  - 이유 : 원본과 복사본이 동일한 배열을 참조하기 때문에 한 쪽의 수정이 발생하면 다른 쪽에도 영향을 끼친다.
  - 하지만, 배열을 clone해도 원본 배열과 복사본 배열의 내부에 존재하는 원소는 같은 인스턴스를 참조하고 있다. 그래서 여기서 또 문제가 발생한다. (shallow copy이기 때문)
  - 이런 경우를 해결하기 위해서는 deep copy를 해야 한다.
    deep copy를 할 때는 새로운 배열을 만들고 해당 배열에 deep copy 해줘야한다.
- clone 메소드 내부에서 오버라이딩할 수 있는 메소드를 호출하면 안된다.
  - 오버라이딩할 수 있는 메소드를 호출한다면, 해당 메소드를 하위 클래스에서 재정의 시 동작이 바뀔 수 있기 때문이다.
- 상속을 위한 클래스는 Cloneable을 구현하지 않는 것이 좋다.
- Cloneable을 구현한 클래스가 스레드 안전해야 한다면 synchronized를 해야한다.

> clone을 사용하는 대신 권장하는 방법

- 복사 용도로 사용하는 생성자 또는 변환 생성자, 복사 용도로 사용하는 팩터리 또는 변환 팩터리
- 생성자를 사용하게 되면 모호한 규약을 벗어날 수 있고, 불필요한 검사를 하지 않아도 되며, final을 자유롭게 사용할 수 있다.
- 또 다른 큰 장점은 인터페이스 타입의 인스턴스를 인수로 받을 수 있다. → 클라이언트가 복제본의 타입을 결정할 수 있다.

> CloneNotSupportedException

Checked Exception의 경우 두 가지 중 하나를 선택해야 한다.

1. try-catch로 잡거나,
2. throw로 exception을 던져야 한다.

Checked Exception을 사용하면 위 두 가지 방법이 귀찮을 수 있지만, 이러한 이유만으로 Unchecked Exception을 사용하는 것은 나이브한 선택이다. (좋은 이유가 될 수 없음)

Checked Exception이 존재하는 이유는 클라이언트에게 해당 API를 사용할 때 Checked Exception이 발생할 수 있다는 것을 알려준다.

→ 클라이언트에서 해당 에러를 복구하거나 조치할 수 있는 방법을 준다.

따라서, UncheckedException은 클라이언트가 해당 예외를 마주쳤을 때 조치할 수 있는 방법이 없는 경우에 사용한다.

그래서, CloneNotSupportedException은 Unchecked Exception이어야하지 않았을까라는 것이 저자의 생각.

→ 예외가 발생해도 처리할 수 있는 방법이 없다.
