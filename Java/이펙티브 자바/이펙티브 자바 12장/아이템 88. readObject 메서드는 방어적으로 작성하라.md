# 아이템 88. readObject 메서드는 방어적으로 작성하라

## readObject

실질적으로 또 다른 생성자
매개변수로 바이트 스트림을 받는 생성자라 할 수 있다.
보통의 경우 바이트 스트림은 정상적으로 생성된 인스턴스를 직렬화해 만들어진다.
하지만 불변식을 깨뜨릴 의도로 임의 생성한 바이트 스트림을 건네면 정상적인 생성자로는 만들어낼 수 없는 객체를 생성해낼 수 있다.
이러한 문제를 고치려면 readObject 메서드가 defaultReadObject 메서드를 호출한 다음 역직렬화된 객체가 유효한지 검사해야 한다.
이 유효성 검사에 실패하면 `InvalidObjectException` 을 던져 잘못된 역직렬화가 일어나는 것을 막을 수 있다.
이러한 작업으로 공격자가 허용되지 않는 인스턴스를 생성하는 일을 막을 수 있지만, 미묘한 문제가 남아있다.
바로, 방어적 복사를 충분히 해야 한다는 점이다.
객체를 역직렬화할 때는 클라이언트가 소유해서는 안 되는 객체 참조를 갖는 필드를 모두 반드시 방어적으로 복사해야 한다.
방어적 복사를 유효성 검사보다 앞서 수행해야 한다.
참고로, final 필드는 방어적 복사가 불가능하니 주의해야 한다.
→ final 한정자를 제거하는 것은 아쉽지만 공격 위험에 노출되는 것보단 좋다.

> 기본 readObject 메서드를 써도 좋을지를 판단하는 간단한 방법

transient 필드를 제외한 모든 필드의 값을 매개변수로 받아 유효성 검사 없이 필드에 대입하는 public 생성자를 추가해도 괜찮은가?

- 예 : 기본 readObejct 사용
- 아니오 : 커스텀 readObject 메서드를 만들어 생성자에서 수행했어야 할 모든 유효성 검사와 방어적 복사를 수행해야 한다.
  또는, 직렬화 프록시 패턴을 사용하는 방법도 있다. → 역직렬화를 안전하게 만드는 데 필요한 노력을 상당히 경감해주는 패턴

final이 아닌 직렬화 가능 클래스라면 readObject와 생성자의 공통점으로 재정의 가능 메서드를 호출해서는 안 된다.
해당 메서드가 재정의되면, 하위 클래스의 상태가 완전히 역직렬화되기 전에 하위 클래스에서 재정의된 메서드가 실행된다
→ 프로그램 오작동으로 이어질 수 있다.

## 정리

readObject 메서드를 작성할 때는 언제나 public 생성자를 작성하는 자세로 임해야 한다.
readObject는 어떤 바이트 스트림이 넘어오더라도 유효한 인스턴스를 만들어내야 한다.
바이트 스트림이 진짜 직렬화된 인스턴스라고 가정해서는 안 된다.

> 안전한 readObject 메서드를 작성하는 지침

- private이어야 하는 객체 참조 필드는 각 필드가 가리키는 객체를 방어적으로 복사하라. 불변 클래스 내의 가변 요소가 여기 속한다.
- 모든 불변식을 검사하여 어긋나는 게 발견되면 `InvalidObjectException` 을 던진다. 방어적 복사 다음에는 반드시 불변식 검사가 뒤따라야 한다.
- 역직렬화 후 객체 그래프 전체의 유효성을 검사해야 한다면 ObjectInputValidation 인터페이스를 사용하라
- 직접적이든 간접적이든 재정의할 수 있는 메서드를 호출하지 말자
