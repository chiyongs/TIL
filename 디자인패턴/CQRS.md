# CQRS

## CQRS

> Command and Query Responsibility Segregation

명령과 쿼리의 책임 분리

### CQRS의 등장

기존 아키텍처는 CRUD 작업이 하나의 모델 안에서 이루어졌습니다.

서비스의 크기가 커지고 복잡해질수록 더더욱 많고 다양한 조회에 대한 요구사항이 생겨났고 이를 만족하기 위해 각각의 모양이 다른 DTO를 반환해야 했습니다.

점점 하나의 모델에서 명령과 쿼리를 모두 수행할 때 다른 성능 또는 요구사항을 포함하게 되어 비대칭적인 구조를 가지게 되었습니다.

명령에 필요한 속성들이 Entity에 추가되면서 쿼리에서 필요없는 데이터를 가져오게 된다거나, 쿼리에 필요한 속성들이 Entity에 추가되면서 명령에서 필요없는 데이터를 가져오게 되는 등 코드의 역할과 책임이 모호해지고 유지보수성이 떨어지게 되는 것이죠.

그렇다면, 왜 이런 현상이 발생하게 되는 걸까요?

명령과 쿼리가 다루는 데이터가 다르기 때문입니다.

명령은 한 영역의 데이터가 필요하고 쿼리는 여러 영역의 데이터가 필요하기 때문입니다.

또한, 코드 변경 빈도와 사용자도 다릅니다.

변경 빈도가 다른 기능이 한 코드에 있으면 서로 다른 이유로 코드가 바뀌고 이는 곧 책임의 크기가 적당하지 않다는 것입니다. (단일 책임 원칙을 위반)

이를 해결하기 위해 CQRS가 등장했습니다.

CQRS를 통해 명령은 데이터 중심이 아닌 작업을 시간으로 진행됩니다.

또한, 동기적으로 처리되지 않고 비동기 처리를 위해 큐에 배치될 수 있습니다.

쿼리는 데이터베이스를 수정하지 않으며 도메인 정보를 캡슐화하지 않는 DTO를 반환합니다.

### Command 명령 & Query 쿼리

명령은 시스템 데이터를 변경하는 것을 말합니다.

예시로 주문 취소 또는 배송 완료처럼 직접적으로 데이터가 수정되는 경우죠.

쿼리는 시스템 데이터를 조회하는 것을 말합니다.

예시로 주문 목록을 조회하는 것이죠.

### Responsibility 책임 & Segregation 분리

책임은 구성 요소의 역할을 말합니다.

구성요소는 작게는 클래스 또는 함수 크게는 웹서버 또는 DB라고 말할 수 있습니다.

분리는 이런 역할에 따라 구성 요소를 나누는 것입니다.

따라서, CQRS는 명령 역할을 수행하는 구성 요소와 쿼리 역할을 수행하는 구성 요소를 나누는 것입니다.

간단히 말하면 시스템 데이터를 변경하는 코드와 시스템 데이터를 조회하는 코드를 따로 만드는 것으로 이야기할 수 있습니다.
