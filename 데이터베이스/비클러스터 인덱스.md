세컨더리 인덱스(secondary index)는 클러스터 인덱스와는 별도로 테이블 내에서 특정 열이나 열의 조합에 대해 추가적인 검색 성능을 향상시키기 위해 생성되는 인덱스입니다. 세컨더리 인덱스는 비클러스터 인덱스(non-clustered index)라고도 불리며, 데이터베이스의 쿼리 성능을 최적화하는 데 중요한 역할을 합니다. 다음은 세컨더리 인덱스에 대한 주요 특징과 개념입니다:

비클러스터 인덱스:

세컨더리 인덱스는 데이터의 물리적 저장 순서에 영향을 주지 않습니다. 대신, 인덱스는 별도의 인덱스 페이지에 저장되며, 인덱스 페이지에는 인덱스 키와 해당 키가 가리키는 데이터의 위치 정보(포인터)가 포함됩니다.
다중 인덱스 생성 가능:

하나의 테이블에는 여러 개의 세컨더리 인덱스를 생성할 수 있습니다. 이는 다양한 쿼리 조건에 맞춰 최적화된 검색 성능을 제공할 수 있게 합니다.
데이터 접근 성능 향상:

세컨더리 인덱스는 특정 열에 대한 검색 속도를 크게 향상시킬 수 있습니다. 예를 들어, LastName 열에 대해 세컨더리 인덱스를 생성하면, 해당 열을 기준으로 하는 검색이 빨라집니다.
구현 예시:

SQL 서버에서 세컨더리 인덱스를 생성하는 예는 다음과 같습니다:
sql
코드 복사
CREATE INDEX idx_lastname ON Employees (LastName);
구조:

세컨더리 인덱스는 B-트리(B-tree) 구조를 사용하는 경우가 많습니다. B-트리는 인덱스 키가 정렬되어 있으며, 각 키는 해당 행의 데이터 페이지를 가리키는 포인터를 포함합니다. 이러한 구조는 검색, 삽입, 삭제 연산에 효율적입니다.
장점과 단점:

장점: 특정 열에 대한 검색 성능 향상, 다양한 쿼리 조건에 대한 유연성 제공.
단점: 인덱스 유지 관리 오버헤드 발생(삽입, 업데이트, 삭제 시), 저장 공간 추가 필요.
클러스터 인덱스와의 차이점:

클러스터 인덱스는 테이블의 데이터 행 자체를 정렬하고, 한 테이블에 하나만 존재할 수 있습니다.
세컨더리 인덱스는 데이터 행의 물리적 순서를 변경하지 않고, 여러 개를 생성할 수 있습니다.
사용 예시:

다음은 세컨더리 인덱스를 생성하고 활용하는 SQL 예제입니다:
sql
코드 복사
CREATE TABLE Employees (
EmployeeID int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
PRIMARY KEY (EmployeeID) -- 프라이머리 키가 클러스터 인덱스를 생성함
);

-- LastName 열에 대해 세컨더리 인덱스 생성
CREATE INDEX idx_lastname ON Employees (LastName);

-- 인덱스를 활용한 쿼리
SELECT \* FROM Employees WHERE LastName = 'Smith';
세컨더리 인덱스는 다양한 쿼리 조건에 대해 효율적인 데이터 접근을 제공하며, 데이터베이스 성능을 최적화하는 데 필수적인 도구입니다. 여러 열에 대해 필요한 경우 여러 개의 세컨더리 인덱스를 생성하여 다양한 검색 요구사항을 충족시킬 수 있습니다.
