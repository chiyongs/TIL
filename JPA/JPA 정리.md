# JPA 기본 정리

객체 지향 프로그래밍과 관계형 데이터베이스 간의 패러다임 불일치

- 상속
- 연관관계
- 데이터 타입
- 데이터 식별 방법

## 상속

상속관계의 객체를 DB에 저장하려면,
각각의 테이블에 따른 JOIN SQL을 작성하고, 각각의 객체를 생성하고 등등 여러 작업들이 필요하다.
→ DB에 저장할 객체에는 상속 관계를 사용하지 않게 됨

하지만, 자바 컬렉션에 저장된 객체는 조회 시 부모 타입으로 조회 후 다형성을 활용할 수 있다.

## 연관관계

테이블에 맞춰 객체를 모델링하게 되면 객체에 연관관계를 위한 외래 키 필드가 필요해진다.
하지만, 객체 지향에서는 객체 자체의 참조로 연관관계를 맺어서 객체 그래프를 순회할 수 있다.

## 엔티티 신뢰 문제

SQL로 데이터를 조회할 때 범위에 맞춰 데이터를 가져오게 되는데 객체 그래프를 순회할 때 해당 데이터가 조회되지 않아 데이터가 채워지지 않은 경우가 발생할 수 있다.
→ 용도에 따라 동일한 엔티티를 여러 번 조회해야 하는 경우가 발생

또한, 동일한 쿼리로 조회하여 만들어진 두 객체가 `==` 연산자로 비교 시 false가 나오게 된다.

객체를 객체답게 모델링할 수록 매핑 작업이 늘어남
→ 객체를 자바 컬렉션에 저장하듯이 DB에 저장하는 방법
→ JPA

## JPA

자바 진영의 ORM 기술의 표준

> ORM

Object-Relational Mapping

- 객체는 객체대로 설계하며 관계형 데이터베이스는 관계형 데이터베이스대로 설계
- ORM 프레임워크가 중간에서 매핑

이점
→ SQL 중심적인 개발에서 객체 중심으로 개발이 가능
→ 생산성 및 유지보수성 향상
→ 데이터 접근 추상화 및 벤더 독립성 등등..

### 생산성

CRUD

- Create : jpa.persist
- Read : jpa.find
- Update : entity.setXX
- Delete : jpa.remove

### 유지보수성

객체 필드 추가 시 SQL 자동 수정

### 성능 최적화

- 1차 캐시와 동일성 보장
  - 같은 트랜잭션 안에서는 같은 엔티티를 반환 → 약간의 조회 성능 향상
  - DB Isolation Level : Read Committed 여도 애플리케이션에서 Repeatable Read 보장
- 트랜잭션을 지원하는 쓰기 지연
  - 트랜잭션을 커밋할 때까지 Insert SQL을 모으고, JDBC BATCH SQL 기능을 사용해서 한 번에 SQL 전송
  - Update, Delete로 인한 Row 락 시간 최소화
  - 트랜잭션 커밋 시 Update, Delete SQL 실행하고 커밋
- 지연 로딩
  - 지연 로딩 : 객체가 실제 사용될 때 로딩
  - 즉시 로딩 : Join SQL로 한 번에 연관된 객체까지 미리 조회

## JPA 구동 방식

1. `Persistence` 클래스가 설정 정보를 조회
2. `Persistence` 클래스가 `EntityManagerFactory`를 생성
3. `EntityManagerFacotry`가 `EntityManager`를 생성

EntityManagerFactory : 1개만 생성해서 애플리케이션 전체에서 공유
EntityManager : 쓰레드 간 공유 X (사용 후 버려야 함)
JPA의 모든 데이터 변경은 트랜잭션 안에서 실행

## JPQL

JPQL : Java Persistence Query Language
-> JPA는 SQL을 추상화한 객체 지향 쿼리 언어를 제공
SQL과 문법이 유사
엔티티 객체를 대상으로 쿼리 -> 테이블이 아닌 객체를 대상으로 검색하는 객체 지향 쿼리
-> 데이터베이스에 의존적이지 않음

## 영속성 컨텍스트

JPA에서 가장 중요한 2가지

- 객체와 관계형 데이터베이스 매핑
- 영속성 컨텍스트

영속석 컨텍스트는 논리적인 개념으로 눈에 보이지 않는다.
엔티티매니저를 통해 영속성 컨텍스트에 접근 가능

엔티티매니저 : 영속성 컨텍스트 = N : 1

### 엔티티 생명주기

- 비영속(new / transient)
  - 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
- 영속 (managed)
  - 영속성 컨텍스트에 관리되는 상태
- 준영속 (detached)
  - 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 (removed)
  - 삭제된 상태

### 영속성 컨텍스트의 이점

- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지 (Dirty Checking)
- 지연 로딩

> 변경 감지
>
> 트랜잭션 커밋 요청이 들어오면 엔티티와 스냅샷을 비교하여 변경이 발생했다면 해당 변경에 대한 SQL을 생성하여 자동으로 반영해주는 기능

### flush

영속성 컨텍스트의 변경 내용을 데이터베이스에 반영
발생 기준

- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송

영속성 컨텍스트를 플러시하는 방법

- em.flush - 직접 호출
- 트랜잭션 커밋 - flush 자동 호출
- JPQL 쿼리 실행 - flush 자동 호출

영속성 컨텍스트를 비우지 않고, 영속성 컨텍스트의 변경내용을 DB에 동기화한다.
-> 트랜잭션 작업 단위가 중요! 커밋 직전에만 동기화하면 됨

### 준영속

영속 상태의 엔티티를 영속성 컨텍스트에서 분리
-> 영속성 컨텍스트의 기능을 사용 못함

준영속 상태로 만드는 방법

- em.detach(entity)
  - 특정 엔티티만 준영속 상태로 전환
- em.clear()
  - 영속성 컨텍스트 초기화
- em.close()
  - 영속성 컨텍스트 종료

## 엔티티 매핑

- 객체와 테이블 매핑 시 : `@Entity`, `@Table`
- 필드와 컬럼 매핑 시 : `@Column`
- 기본 키 매핑 시 : `@Id`
- 연관관계 매핑 시 : `@ManyToOne`, `@JoinColumn` …

> `@Entity` 사용시 주의사항

- 기본 생성자 필수
- final 클래스, enum, interface, inner 클래스 사용 X
- 저장할 필드에 final 사용 X

### 필드와 컬럼 매핑

- 컬럼 매핑 : `@Column`
- 날짜 타입 매핑 : `@Temporal`
- Enum 타입 매핑 : `@Enumerated`
  - EnumType.ORDINAL 사용 X → Enum 순서를 DB에 저장하기 때문에, Enum 순서 변경 시 데이터가 다 틀어짐
- BLOB, CLOB 매핑 : `@Lob`
- 특정 필드를 컬럼에 매핑하지 않음 : `@Transient`

### 기본 키 매핑

- `@Id`
- `@GeneratedValue`
  - IDENTITY : 데이터베이스에 위임, MySQL
  - SEQUENCE : 데이터베이스 시퀀스 오브젝트 사용, Oracle
    - DB에서 시퀀스 기능을 지원해야만 사용 가능한 전략
    - `@SequenceGenerator` 필요
  - TABLE : 키 생성용 테이블 사용, 모든 DB에서 사용 가능
    - `@TableGenerator` 필요
  - AUTO : 방언에 따라 자동 지정, 기본 값
