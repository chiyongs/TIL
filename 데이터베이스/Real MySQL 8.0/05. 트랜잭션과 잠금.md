# 5.1 트랜잭션

## 트랜잭션

트랜잭션 : 작업의 완전성을 보장해주는 기능 → 논리적인 작업 세트가 100% 처리되거나, 원상태로 복구되거나를 보장해줌

- 락 : 동시성을 제어하기 위한 기능
- 트랜잭션 : 데이터의 정합성을 위한 기능

MySQL에는 3가지 스토리지 엔진 존재

- MyISAM → 트랜잭션 미지원
- MEMORY → 트랜잭션 미지원
- InnoDB → 트랜잭션 지원

트랜잭션을 지원하지 않으면 부분 실행이라는 것이 발생할 수 있다.
부분 실행은 쿼리 수행 시 예외가 발생했거나 실패했을 때 해당하는 쿼리 전으로는 적용되는 것을 말함
따라서, 부분 실행으로 인해 변경된 데이터에 대해서 어떻게 처리할 것인가에 대한 고민이 필요함.
→ 트랜잭션이 애플리케이션을 개발하는 데 있어 고민할 부분을 덜어준다고 볼 수 있음

트랜잭션은 DB 커넥션처럼 최소화해서 사용하는 것이 좋음.

## 락

- MySQL 엔진 : 스토리지 엔진을 제외한 MySQL
  - MySQL 엔진 레벨의 락은 스토리지 엔진 레벨 락에 영향을 준다.
- 스토리지 엔진

### MySQL 엔진 락 종류

글로벌 락

- 모든 세션에 대해 잠금하는 락
- 조회를 제외한 모든 작업이 불가능
- `FLUSH TABLES WITH READ LOCK`

백업 락

- 특정 세션에 대해 잠금하는 락
- 데이터베이스 및 테이블 같은 객체 생성,변경,삭제 금지 & 사용자 권한 및 비밀번호 변경 금지
- but, 일반적인 테이블의 데이터 변경은 허용
- `LOCK INSTANCE FOR BACKUP`

테이블 락

- 개별 테이블을 잠금하거나 해제하는 락
- 명시적 또는 묵시적으로 획득할 수 있음
- `LOCK TABLES table_name [ READ | WRITE ]`
- InnoDB에서 데이터 변경 시 테이블 락 적용, 대부분 DML들은 락을 무시, 스키마를 변경하는 등의 DDL은 락에 영향받음

네임드 락

- 사용자가 지정한 문자열을 잠금하거나 해제하는 락
- 잘 쓰이지는 않으나, 많은 레코드에 대해 복잡한 조건으로 변경을 진행하는 배치 작업에서 동시성을 위해 사용할 수 있음
- `SELECT GET_LOCK('mylock', 2)` : "mylock" 문자열에 대해 락을 획득
- `SELECT IS_FREE_LOCK('mylock')` : "mylock" 문자열에 대해 락이 설정되어 있는지 확인
- `SELECT RELEASE_LOCK('mylock)` : "mylock" 문자열에 대해 획득했던 락을 반납

메타데이터 락

- 데이터베이스 객체의 이름이나 구조 변경 시 걸리는 락
- 명시적으로 획득할 수 없음
- `RENAME TABLE table_a TO table_b`

### InnoDB 스토리지 엔진 락 종류

InnoDB는 레코드 기반의 락을 사용해서 동시성이 좋다.

레코드 락

- 다른 상용 DBMS와 같이 레코드에 락을 건다.
- 레코드 자체에 락을 걸지 않고, 레코드의 인덱스에 락을 건다 → 성능 상 이점을 가져감
- 인덱스가 없는 테이블이라면 내부적으로 생성된 클러스터 인덱스에 락을 건다.

갭 락

- 레코드와 레코드 사이에 락을 건다.
- 레코드 사이에 다른 데이터가 insert되는 것을 제어한다.

넥스트 키 락

- 레코드 락과 갭 락을 같이 사용하는 락
- STATEMENT 바이너리 로그 + innodb_locks_unsafe_for_binlog → 넥스트 키 락
- 바이너리 로그에 기록된 쿼리를 사용하는 레플리카 서버에서 동일한 값을 만들기 위한 것이 주 목적

자동 증가 락 Auto increment lock

- AUTO_INCREMENT 속성이 걸려있는 값에 insert, replace 명령어를 수행하면 락이 걸린다.
- auto_increment 값을 가져올 때만 락을 걸고 값을 받으면 락을 해제한다.
- 짧게 락을 가져간다.
- 테이블에는 단 하나의 AUTO INCREMENT LOCK이 존재한다.
- 한 INSERT 문장이 자동 증가 락을 가지고 있으면, 다른 INSERT 문장은 기다려야 한다.
- MySQL 5.0 이하에서는 AUTO INCREMENT LOCK만 사용
- MySQL 5.1 이상에서는 innodb_autoinc_lock_mode 사용
- innodb_autoinc_lock_mode
  - 0 → AUTO INCREMENT LOCK 사용
  - 1 → INSERT 되는 레코드 건 수를 정확히 알 땐 래치(뮤텍스) 사용, 모르면 자동 증가 락 사용
    - 한 INSERT 문장에서 추가된 레코드들은 연속된 증가 값을 보장
    - 대량의 INSERT 시 AUTO INCREMENT 값을 한번에 받아오기 때문에 값이 남으면 버림
    - 완벽하게 증가된 값은 아님
  - 2 → 자동 증가 락 사용하지 않고, 래치만 사용, 인터리빙 모드
    - 한 INSERT 문장 내 추가된 레코드들에 대해 연속된 증가 값을 보장하지 않음
    - INSERT 된 레코드들이 유니크한 값을 가지는 것만 보장
    - MySQL 8.0 부터는 ROW 바이너리 로그 사용하여 기본 값 채택

## 인덱스와 락

MySQL InnoDB 스토리지 엔진 : 레코드 기반 락
레코드의 인덱스에 락을 건다.
→ 검색한 인덱스에 모두 락을 건다.

만약, 인덱스가 없는 테이블이라면 풀 스캔을 하게 되고 풀 스캔 시 모든 레코드가 락에 걸린다.
→ 적절한 인덱스가 없으면 동시성이 떨어진다.

## 트랜잭션 격리 수준

- Read Uncommited
  - 한 트랜잭션의 변경이 완료되지 않아도 다른 트랜잭션에서 읽거나 쓸 수 있는 격리 수준
  - Dirty Read 발생 → 데이터가 보였다 안보였다 하여 사용자와 개발자를 혼동시킬 수 있음
  - 데이터 정합성에 문제가 발생할 수 있어 사용하지 않는 것을 권장
- Read Commited
  - 한 트랜잭션의 변경이 완료되어야 해당 변경사항을 다른 트랜잭션에서 읽거나 쓸 수 있는 격리 수준
  - 한 트랜잭션에서의 변경이 끝나지 않은 상태에서 다른 트랜잭션이 접근 시 Undo 영역을 참조해 값을 가져간다.
  - 대부분 온라인 애플리케이션 서비스들에서 사용하는 격리 수준이며, Oracle의 기본 격리 수준
  - Non-Repeatable Read 발생 : 한 트랜잭션 내 동일한 쿼리 조회 시 다른 결과가 나타나는 현상
- Repeatable Read
  - MySQL의 기본 격리 수준
  - 한 트랜잭션 내 동일한 조회에 대한 동일한 결과를 보장하는 격리 수준
  - 트랜잭션 별로 고유의 id 값을 가지며 Undo 영역에서 해당 트랜잭션의 id 값 이하의 변경사항에 대해서만 바라봄
  - MySQL은 MVCC를 사용하여 동시성 향상
  - Phantom Read 발생 : SELECT … FOR UPDATE 사용 시 Undo 영역에는 락을 걸 수 없어 현재 레코드의 값을 가져오게 됨
- Serializable
  - 가장 높은 수준의 격리 수준
  - 동시성이 안 좋아서 분산 처리 시스템에서 사용하기엔 성능이 좋지 않음
  - MySQL에서 순수한 SELECT 구문은 락을 잡지 않는데, 해당 격리 수준 사용 시 읽기 락을 사용하게 되어 순수한 SELECT 구문에 영향을 받는 레코드들도 락에 걸려 동시성 하락
