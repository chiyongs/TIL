# Redis 클러스터 사양

Redis Cluster에 대한 공식문서를 기반으로 번역해가며 공부하는 문서입니다.

## 디자인의 주요 속성 및 근거

### Redis 클러스터 목표

Redis 클러스터는 설계 시 중요도 순으로 다음과 같은 목표를 가진 Redis의 분산 구현입니다.

- 최대 1000개 노드까지 높은 성능과 선형 확장성을 제공합니다. 프록시가 없고, 비동기 복제가 사용되며, 값에 대한 병합 작업이 수행되지 않습니다.
- 허용 가능한 쓰기 안전 수준 : 시스템은 대부분의 마스터 노드에 연결된 클라이언트에서 발생하는 모든 쓰기를 (최선의 노력으로) 보존하려고 합니다. 일반적으로 확인된 쓰기가 손실될 수 있는 작은 윈도우(시간대)가 존재합니다. 클라이언트가 소수 파티션에 있을 때 확인된 쓰기가 손실되는 윈도우(시간대)가 더 큽니다.
- 가용성 : Redis 클러스터는 대부분의 마스터 노드에 접근 가능하고 더 이상 접근 불가능한 마스터 노드에 대해 접근 가능한 복제본이 하나 이상 존재하는 파티션에서도 작동할 수 있습니다. 또한 복제본 마이그레이션을 사용하면, 어떤 복제본에도 더 이상 복제되지 않는 마스터는 여러 복제본으로 구성된 마스터로부터 복제본을 받게 됩니다.
  (Redis 3.0 이상에서 구현되는 항목들)

### 구현된 하위 집합

Redis 클러스터는 비분산형 Redis 버전에서 사용 가능한 모든 단일 키 명령을 구현합니다. 집합, 합집합 및 교집합과 같은 복잡한 다중 키 연산을 수행하는 명령은 해당 연산에 관련된 모든 키가 동일한 슬롯에 해시되는 경우에 구현됩니다.
Redis 클러스터는 해시 태그라는 개념을 구현하는데, 이를 통해 특정 키가 동일한 해시 슬롯에 저장되도록 강제할 수 있습니다. 그러나 수동 리샤딩 중에는 단일 키 작업은 항상 사용 가능하지만 다중 키 작업은 한동안 사용할 수 없게 될 수 있습니다.
Redis 클러스터는 독립형 Redis 버전처럼 여러 데이터베이스를 지원하지 않습니다. 데이터베이스는 0번만 있으며, SELECT 명령은 허용되지 않습니다.

## Redis 클러스터 프로토콜의 클라이언트 및 서버 역할

Redis 클러스터에서 노드는 데이터를 보관하고 클러스터 상태를 가져오는 역할을 하며, 키를 올바른 노드에 매핑하는 작업도 수행합니다. 또한 클러스터 노드는 다른 노드를 자동으로 검색하고, 작동하지 않는 노드를 감지하고, 장애 발생 시에도 계속 작동할 수 있도록 필요에 따라 복제본 노드를 마스터 노드로 승격시킬 수 있습니다.

모든 클러스터 노드는 작업을 수행하기 위해 TCP 버스와 Redis 클러스터 버스라는 바이너리 프로토콜을 사용하여 연결됩니다. 각 노드는 클러스터 버스를 통해 클러스터의 다른 모든 노드와 연결됩니다. 노드는 가십 프로토콜을 사용하여 클러스터에 대한 정보를 전파하여 새 노드를 검색하고, 다른 모든 노드가 제대로 작동하는지 확인하기 위해 ping 패킷을 전송하고, 특정 상태를 알리는 데 필요한 클러스터 메시지를 전송합니다. 클러스터 버스는 또한 클러스터 전체에 Pub/sub 메시지를 전파하고 사용자의 요청 시 수동 장애 조치를 조정하는 데에도 사용합니다.
(수동 장애 조치는 Redis 클러스터 장애 감지기가 아닌 시스템 관리자가 직접 시작하는 장애 조치입니다.)

클러스터 노드는 요청을 프록시할 수 없으므로, 클라이언트는 -MOVED 및 -ASK 리다이렉션 오류를 사용하여 다른 노드로 리다이렉션될 수 있습니다. 클라이언트는 이론적으로 클러스터의 모든 노드에 요청을 보낼 수 있으며, 필요한 경우 리다이렉션되므로 클러스터 상태를 유지할 필요가 없습니다. 하지만 키와 노드 간의 맵을 캐시할 수 있는 클라이언트는 성능을 상당히 향상시킬 수 있습니다.

### 쓰기 안전

Redis 클러스터는 노드 간 비동기 복제를 사용하며, 마지막 장애 조치가 암묵적 병합 기능을 이깁니다. 즉, 마지막으로 선출된 마스터 데이터 세트가 결국 다른 모든 복제본을 대체합니다. 파티션 작업 중에 쓰기 데이터가 손실될 수 있는 시간대가 항상 존재합니다. 그러나 이러한 시간대는 다수의 마스터에 연결된 클라이언트와 소수의 마스터에 연결된 클라이언트의 경우 매우 다릅니다.

Redis 클러스터는 소수 쪽에서 수행된 쓰기보다 다수의 마스터에 연결된 클라이언트에서 수행된 쓰기를 더 많이 보존하려고 합니다. 다음은 장애 발생 시 다수 쪽 파티션에서 수신된 확인된 쓰기가 손실되는 시나리오의 예입니다.

1. 쓰기는 마스터에 도달할 수 있지만, 마스터가 클라이언트에 응답할 수는 있어도 마스터와 복제본 노드 간에 사용되는 비동기 복제를 통해 복제본에 전파되지 않을 수 있습니다. 쓰기가 복제본에 도달하지 않고 마스터가 종료되면, 마스터에 오랫동안 접속할 수 없어 복제본 중 하나가 승격되면 쓰기는 영구적으로 손실됩니다. 마스터 노드가 갑자기 완전히 고장난 경우에는 마스터가 클라이언트(쓰기 확인 응답)와 복제본(쓰기 전파)에 거의 동시에 응답하려고 하기 대문에 이러한 현상을 관찰하기 어렵습니다. 하지만 이는 현실 세계에서 발생하는 장애 케이스입니다.
2. 이론적으로 쓰기가 손실되는 다른 장애 케이스는 다음과 같습니다.

- 파티션으로 인해 마스터에 접근 불가
- 해당 마스터의 복제본 중 하나에 장애 발생
- 시간이 지난 후 마스터에 접속 가능성 존재
- 오래된 라우팅 테이블을 사용하는 클라이언트는 클러스터에서 새 마스터의 복제본으로 변환되기 전에 이전 마스터에 쓸 수 있는 가능성 존재

2번째 장애 케이스는 발생할 가능성이 낮습니다. 마스터 노드가 장애 조치를 수행할 만큼 충분한 시간 동안 다른 마스터 노드들과 통신할 수 없으면 더 이상 쓰기를 허용하지 않기 때문입니다. 파티션이 고정된 경우에도 다른 노드가 구성 변경 사항을 알릴 수 있도록 잠시 동안 쓰기가 거부됩니다. 또한 이 장애 케이스는 클라이언트의 라우팅 테이블이 아직 업데이트되지 않았음을 요구합니다.

파티션의 소수 그룹을 대상으로 하는 쓰기는 손실될 가능성이 더 큽니다. 예를 들어, Redis 클러스터는 소수 그룹의 마스터와 하나 이상의 클라이언트가 있는 파티션에서 상당한 수의 쓰기 손실을 발생시킵니다. 마스터가 다수 그룹에서 장애 조치될 경우 마스터로 전송된 모든 쓰기가 손실될 가능성이 있기 때문입니다.

특히 마스터가 장애조최되려면 적어도 NODE_TIMEOUT 동안 과반수의 마스터에 의해서 접근할 수 없는 상태가 되어야 하고, 그래서 만약 파티션이 그 시간 이전에 해소되면 쓰기의 손실은 없습니다. 파티션이 NODE_TIMEOUT 이상 지속될 때, NODE_TIMEOUT 시간까지 소수 측에서 실행된 모든 쓰기가 손실될 수도 있습니다. 그러나 소수 측의 Redis 클러스터는 NODE_TIMEOUT 이 경과하자마자, 과반수 측과의 연락없이 쓰기는 거절하기 시작하므로, 최대의 시간이 존재하며, 그 이후에는 소수 쪽은 더 이상 사용할 수 없는 상태가 됩니다. 이런 이유로 이 시간 이후에는 쓰기가 받아들여지거나, 손실되지도 않습니다.

### 가용성

Redis 클러스터는 파티션의 소수 측에서 사용할 수 없습니다. 파티션의 다수 측에 마스터의 과반수와 접근할 수 없는 모든 마스터에 대한 복제본이 있다고 가정할 때,
클러스터는 NODE_TIMEOUT 시간과 복제본이 선출되고 마스터를 페일오버하는 데 필요한 몇 초가 더 지나면 다시 사용할 수 있게 됩니다.
(페일오버는 일반적으로 1~2초 내에 실행됩니다.)

즉, Redis 클러스터는 클러스터 내 몇몇 노드의 장애를 견뎌내도록 설계되었지만, 대규모 네트워크 분할 발생 시 가용성이 필요한 애플리케이션에는 적합한 솔루션이 아닙니다.

각 노드에 단일 복제본이 있는 N개의 마스터 노드로 구성된 클러스터의 예에서 클러스터의 다수는 단일 노드가 분할되는 한 사용 가능한 상태를 유지하며, 두 개의 노드가 분할되는 경우에도 1 - (1/(N*2-1))의 확률로 사용 가능한 상태를 유지합니다.
(첫 번째 노드가 실패하면 총 N*2-1개의 노드가 남고 복제본이 없는 유일한 마스터가 실패할 확률은 1/(N\*2-1)입니다.)

예를 들어, 5개의 노드와 노드당 하나의 복제본이 있는 클러스터에서 두 개의 노드가 다수로부터 분할된 후 클러스터를 더 이상 사용할 수 없게 될 확률은 1/(5\*2-1) = 11.11% 입니다.

Redis 클러스터의 복제본 마이그레이션 기능 덕분에 복제본이 고아 마스터(더 이상 복제본이 없는 마스터)로 마이그레이션되므로 여러 실제 상황에서 클러스터 가용성이 향상됩니다. 따라서 모든 성공적인 장애 발생 시, 클러스터는 다음 장애에 더 잘 대처하기 위해 복제본 레이아웃을 재구성할 수 있습니다.

### 성능

Redis 클러스터에서는 노드가 주어진 키에 대한 책임을 맡고 있는 올바른 노드로 명령을 프록시하지 않고, 대신 키 공간의 주어진 부분을 담당하는 올바른 노드로 클라이언트를 리다이렉션합니다.

결국 클라이언트는 클러스터의 최신 상태와 어떤 노드가 어떤 키 하위 집합을 제공하는지 알게 되므로, 일반적인 작업 중에 클라이언트는 주어진 명령을 보내기 위해 올바른 노드에 직접 접속합니다.

비동기 복제를 사용하므로 노드는 다른 노드의 쓰기 확인을 기다리지 않습니다.
(WAIT 명령을 사용하여 명시적으로 요청하지 않은 경우)

또한, 다중 키 명령은 가까운 키에만 제한되므로 리샤딩을 제외하고는 노드 간에 데이터가 이동하지 않습니다.

일반 작업은 단일 Redis 인스턴스의 경우와 동일하게 처리됩니다. 즉, N개의 마스터 노드가 있는 Redis 클러스터에서는 설계가 선형적으로 확장됨에 따라 단일 Redis 인스턴스에 N을 곱한 것과 동일한 성능을 기대할 수 있습니다. 동시에, 클라이언트는 일반적으로 노드와 지속적인 연결을 유지하므로 쿼리는 일반적으로 단일 왕복으로 수행되므로 지연 시간 수치도 단일 독립형 Redis 노드의 경우와 동일합니다.

Redis 클러스터의 주요 목표는 약하지만 합리적인 형태의 데이터 안전성과 가용성을 유지하면서 매우 높은 성능과 확장성을 제공하는 것입니다.

### 병합 작업이 피해지는 이유

Redis 클러스터 설계는 여러 노드에서 동일한 키-값 쌍의 버전이 충돌하는 것을 방지합니다. Redis 데이터 모델의 경우, 이러한 충돌이 항상 바람직한 것은 아닙니다. Redis의 값은 종종 매우 크기 대문에 수백만 개의 요소가 있는 목록이나 정렬된 집합을 흔히 볼 수 있습니다. 또한 데이터 유형은 의미적으로 복잡합니다. 이러한 종류의 값을 전송하고 병합하는 것은 심각한 병목 현상을 초래할 수 있으며, 애플리케이션 측 로직, 메타데이터 저장을 위한 추가 메모리 등이 필요할 수 있습니다.

여기에는 엄격한 기술적 제한이 없습니다. CRDT 또는 동기 복제 상태 머신은 Redis와 유사한 복잡한 데이터 유형을 모델링할 수 있습니다. 그러나 이러한 시스템의 실제 런타임 동작은 Redis 클러스터와 유사하지 않습니다. Redis 클러스터는 비클러스터형 Redis 버전의 정확한 사용 사례를 포괄하도록 설계되었습니다.
