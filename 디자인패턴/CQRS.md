# CQRS

## CQRS

> Command and Query Responsibility Segregation

명령과 쿼리의 책임 분리

### CQRS의 등장

기존 아키텍처는 CRUD 작업이 하나의 모델 안에서 이루어졌습니다.

서비스의 크기가 커지고 복잡해질수록 더더욱 많고 다양한 조회에 대한 요구사항이 생겨났고 이를 만족하기 위해 각각의 모양이 다른 DTO를 반환해야 했습니다.

점점 하나의 모델에서 명령과 쿼리를 모두 수행할 때 다른 성능 또는 요구사항을 포함하게 되어 비대칭적인 구조를 가지게 되었습니다.

명령에 필요한 속성들이 Entity에 추가되면서 쿼리에서 필요없는 데이터를 가져오게 된다거나, 쿼리에 필요한 속성들이 Entity에 추가되면서 명령에서 필요없는 데이터를 가져오게 되는 등 코드의 역할과 책임이 모호해지고 유지보수성이 떨어지게 되는 것이죠.

그렇다면, 왜 이런 현상이 발생하게 되는 걸까요?

명령과 쿼리가 다루는 데이터가 다르기 때문입니다.

명령은 한 영역의 데이터가 필요하고 쿼리는 여러 영역의 데이터가 필요하기 때문입니다.

또한, 코드 변경 빈도와 사용자도 다릅니다.

변경 빈도가 다른 기능이 한 코드에 있으면 서로 다른 이유로 코드가 바뀌고 이는 곧 책임의 크기가 적당하지 않다는 것입니다. (단일 책임 원칙을 위반)

이를 해결하기 위해 CQRS가 등장했습니다.

CQRS를 통해 명령은 데이터 중심이 아닌 작업을 시간으로 진행됩니다.

또한, 동기적으로 처리되지 않고 비동기 처리를 위해 큐에 배치될 수 있습니다.

쿼리는 데이터베이스를 수정하지 않으며 도메인 정보를 캡슐화하지 않는 DTO를 반환합니다.
