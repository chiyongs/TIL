# 06. 파티셔닝

대체로 각 데이터 단위를 1개의 파티션으로 만든다.
그 자체로 1개의 작은 데이터베이스.
파티셔닝을 하는 주 된 원인은 확장성

단일 파티션에 실행되는 질의를 각 노드에서 자신의 파티션으로 해당 질의를 독립적으로 실행하게 되면
-> 노드를 추가할 때마다 질의 처리량이 증가

## 파티셔닝과 복제

1개의 노드에 여러 파티션이 존재 가능
각 노드에서 각 파티션은 리더일 수도 있고 팔로워일 수도 있다.
: 리더-팔로워 복제 모델

## 키-값 데이터 파티셔닝

파티셔닝 : 데이터와 질의 부하를 각 노드에 균등하게 분산시키는 것
동일한 분량을 담당한다는 가정 하에 1개의 노드가 10개의 노드가 되면
-> 10배의 데이터를 저장할 수 있고, 10배의 읽기, 쓰기 요청에 대한 처리가 가능

쏠림 : 파티셔닝이 고르게 이루어지지 않아 다른 파티션보다 데이터가 많거나 질의 처리를 많이 하는 파티션이 존재하는 경우
핫스팟 : 불균형하게 부하가 높은 파티션

핫스팟을 해결하는 가장 쉬운 방법
: 데이터 저장 시 무작위로 분산하여 저장
-> 데이터를 모두 고르게 분산할 수 있지만, 데이터 탐색 시 모든 노드에서 병렬적으로 탐색을 수행해야 함

키-값 데이터 모델
: 항상 기본 키를 통해 레코드에 접근
-> 항상 빨리 찾을 수 있다.
ex) 백과사전

## 키 범위 기준 파티셔닝

파티셔닝 방법 : 백과사전
각 파티션에 연속된 범위의 키를 할당
-> 각 범위의 경계를 알면 데이터를 어디에 저장했는지 파악이 쉬움
(어느 키가 어느 파티션에 속하는지)

각 파티션이 어느 노드에 할당되어 있는지 알면 적절한 노드로 요청도 가능

키 범위가 파티션별로 동일할 필요는 없다.
데이터에 맞게 범위는 조정되어야 한다.
그렇지 않으면 데이터 쏠림 현상이 발생할 수 있다.

각 파티션 내에서 키는 정렬된 순서로 유지된다.
그로 인해 빠르게 탐색이 가능하다.
하지만, 키 범위 기준 파티셔닝은 특정 접근 패턴에 대해 핫스팟을 유발할 수 있다.
예를 들어, 타임스팸프가 키라면 해당 날짜에 대한 파티션만 부하를 받고 나머지는 유휴 상태로 유지

## 키의 해시값 기준 파티셔닝

쏠림과 핫스팟 위험때문에 많은 분산 데이터 스토어는 키의 파티션을 정하는데 해시함수를 적용
좋은 해시 함수 : 쏠린 데이터를 균일하게 분산
암호적으로 강력할 필요는 없다.
ex) 카산드라와 몽고DB : MD5, 볼드모트 : 파울러-놀-보
프로그래밍 언어에서 지원하는 내장 해시 함수는 파티셔닝에는 적합 X

각 파티션에 해시값 범위 할당하고, 해시값이 파티션 범위에 속하는 모든 키를 해당 파티션에 할당
-> 키를 파티션에 균일하게 분산시키기에 좋음
하지만, 키의 해시값으로 파티셔닝하면 범위 질의를 효율적으로 실행할 수 있는 키 범위 파티셔닝의 장점을 잃어버림
-> 인접했던 키들이 모든 파티션에 흩어져서 정렬 순서가 유지되지 않기 때문
-> 해시값으로 파티셔닝하면 범위 질의가 모든 파티션에 전송되어야 함

카산드라는 두 가지 파티셔닝(키 범위 기준 파티셔닝, 키의 해시값 기준 파티셔닝)에서 타협

- 여러 칼럼을 포함하는 복합 기본키 지정

첫 번째 키에만 해싱을 적용해 파티션 결정에 사용
남은 키에는 데이터를 정렬하는 연쇄된 색인으로 사용
-> 복합 키의 첫 번째 칼럼에 대해서 값 범위로 검색하는 질의는 사용 불가
-> 하지만, 첫 번째 칼럼에 고정된 값 적용하면 다른 칼럼에 대해서는 효율적인 범위 스캔 가능

이로인해 연쇄된 색인을 사용하면 일대다 관계를 표현하는 우아한 데이터 모델 설계 가능

## 쏠린 작업부하와 핫스팟 완화

키의 해시값으로 파티셔닝 -> 핫스팟을 줄이는데 도움
하지만, 핫스팟을 완벽히 제거는 불가능
항상 동일한 키를 읽고 쓰는 극단적인 상황에서는 모든 요청이 동일한 파티션으로 쏠리게 된다.
ex) SNS에서 수 백만명의 팔로워를 거느린 유명인의 행동
(동일한 ID의 해시값은 동일 -> 해싱은 도움 X)

현대 데이터 시스템은 대부분 크게 쏠린 작업부하를 자동으로 보정 불가능
-> 애플리케이션에서 쏠림을 완화해야 함.
요청이 매우 많이 쏠리는 키를 발견했을 때의 간단한 해결책
: 각 키의 시작이나 끝에 임의의 숫자를 붙이는 것
이로써 한 키에 대한 쓰기 작업이 여러 개의 다른 키로 균등하게 분산, 그 키들은 다른 파티션으로 분산
하지만, 다른 키에 쪼개서 쓰면 발생하는 단점
: 추가적인 작업 필요

- 여러 개의 키에 해당하는 데이터를 읽어서 조합해야 함 & 추가적으로 저장해야 할 정보도 존재
  -> 요청이 몰리는 소수의 키에만 적용하는 게 타당
  쓰기 처리량이 낮은 대다수의 키에도 적용 시 불필요한 오버헤드 발생
