# 4장. 분산 메시지 큐

분산 메시지 큐 사용 시 이점

- 결합도 완화 : 강결합 사라짐
- 규모 확장성 개선 : 생산자와 소비자가 독립적
- 가용성 개선 : 개별 컴포넌트의 장애와 상관없이 다른 컴포넌트는 큐와 상호작용
- 성능 개선 : 비동기 통신 가능

## 기능 요구사항

- 생산자는 메시지 큐에 메시지를 보낼 수 있어야 한다.
- 소비자는 메시지 큐를 통해 메시지를 수신할 수 있어야 한다.
- 메시지는 반복적으로 수신 or 단 한 번만 수신하도록 설정
- 오래된 이력 데이터 삭제될 수 있다.
- 메시지 크기는 킬로바이트 수준
- 메시지는 생산된 순서대로 소비자에게 전달
- 메시지 전달 방식은 최소 한 번, 최대 한 번, 정확히 한 번 가운데 설정할 수 있어야 한다.

## 비기능 요구사항

- 높은 대역폭과 낮은 전송 지연 가운데 하나를 설정할 수 있어야 하는 기능
- 규모 확장성, 메시지 양이 급증해도 처리 가능해야 함
- 지속성 및 내구성, 데이터는 디스크에 지속적으로 보관 & 여러 노드에 복제되어야 함

### 전통적 메시지 큐와 다른 점

전통적 메시지 큐 : 메시지 보관 문제 중요 X
-> 메시지가 소비자에게 전달되기 충분한 기간동안만 메모리에 보관
메시지 전달 순서도 보존 X
-> 생산된 순서와 소비되는 순서 다를 수 있음

## 메시지 모델

### 일대일 (point to point)

- 전통적인 메시지 큐에서 흔히 발견되는 모델
- 오직 한 소비자만 메시지를 소비
- 데이터 보관 (Data Retention) 지원 X

과정

1. 소비지가 메시지 가져감
2. 소비자가 큐에 알림 (Acknowledge)
3. 메시지 큐에서 삭제

### 발행-구독 (publish-subscribe)

토픽 : 메시지를 주제별로 정리하는 데 사용
각 토픽은 메시지 큐 서비스 전반에 고유한 이름을 가짐

토픽에 전달된 메시지는 해당 토픽을 구독하는 모든 소비자에게 전달

#### 토픽, 파티션, 브로커

토픽에 보관되는 데이터의 양이 커져서 서버 한 대로 감당이 어려움
-> 파티션 사용으로 해결 가능
토픽을 여러 파티션으로 분할한 다음, 메시지를 모든 파티션에 균등하게 나눠 보냄
-> 파티션 : 토픽에 보낼 메시지의 작은 부분 집합

파티션은 메시지 큐 클러스터 내의 서버에 고르게 분산 배치함
파티션을 유지하는 서버 -> 브로커
파티션을 브로커에 분산하는 것이 높은 규모 확장성을 달성하는 비결
토픽의 용량을 확장하고 싶으면 파티션 개수를 늘리면 됨

각 토픽 파티션은 FIFO로 동작
-> 같은 파티션 안에서는 메시지 순서가 유지됨

생산자가 보낸 메시지는 해당 토픽의 파티션 중 하나로 보내짐

- 같은 키를 가진 모든 메시지는 같은 파티션으로 보내짐
- 키가 없는 메시지는 랜덤한 파티션으로 보내짐

토픽을 구독하는 소비자는 하나 이상의 파티션에서 데이터를 가져오게 된다.
-> 소비자가 파티션보다 많으면 유휴 소비자 발생 가능

#### 소비자 그룹

하나의 소비자 그룹은 여러 토픽 구독 & 오프셋을 별도로 관리
같은 그룹 내의 소비자는 메시지를 병렬로 소비 가능
-> 병렬로 소비 시 대역폭 좋음, 하지만 같은 파티션 안에 있는 메시지를 순서대로 소비 불가능
-> 소비 순서 보장 불가능

소비 순서 보장 방법
: 어떤 파티션의 메시지는 한 그룹 안에서는 오직 한 소비자만 읽을 수 있도록 강제
-> 그룹 내 소비자 수가 구독하는 토픽의 파티션 수보다 많으면 유휴 소비자 발생

## 개략적 설계안

클라이언트

- 생산자 : 메시지를 특정 토픽으로 보낸다
- 소비자 그룹 : 토픽을 구독하고 메시지를 소비한다

핵심 서비스 및 저장소

- 브로커 : 파티션들을 유지, 하나의 파티션은 특정 토픽에 대한 메시지의 부분 집합을 유지
- 데이터 저장소 : 메시지는 파티션 내 데이터 저장소에 보관
- 상태 저장소 : 소비자 상태 저장
- 메타데이터 저장소 : 토픽 설정, 토픽 속성 등 저장
- 조정 서비스
  - 서비스 탐색 (Service Discovery) : 어느 브로커가 살아있는지
  - 리더 선출 : 브로커 가운데 하나는 컨트롤러 역할을 담당. 한 클러스터에는 반드시 활성 상태의 컨트롤러가 1개는 존재해야함. 파티션 배치를 책임

## 상세 설계

데이터 장기 보관 및 높은 대역폭 제공을 위한 3가지 결정

- 디스크 기반 자료구조 활용
- 메시지가 생산자 -> 소비자에게 전달되는 순간까지 아무 수정 없이 전송 가능한 메시지 자료구조
- 일괄 처리를 우선하는 시스템 설계, 소규모 I/O 많으면 높은 대역폭 지원 어려움.
  생산자는 메시지 일괄 전송, 메시지 큐는 그 메시지들을 더 큰 단위로 묶어 보관, 소비자도 가능하면 메시지 일괄 수신

### 데이터 저장소

메시지 큐의 트래픽 패턴

- 읽기와 쓰기가 빈번하게 발생
- 갱신/삭제 연산은 발생 X
- 순차적인 읽기/쓰기가 대부분

WAL (Write Ahead Log), 쓰기 우선 로그
: 새로운 항목이 추가되기만 하는 append-only 일반 파일
MySQL의 복구 로그 (redo log), 아파치 주키퍼에서도 활용

지속성을 보장해야 하는 메시지는 디스크에 WAL로 보관할 것을 추천
WAL의 접근 패턴 : 읽기/쓰기 전부 순차적
-> 접근 패턴이 순차적일때 디스크는 아주 좋은 성능을 보임

새로운 메시지는 파티션 꼬리 부분에 추가, 오프셋은 그 결과로 점진적으로 증가
세그먼트 단위로 관리.
비활성 세그먼트 파일은 보관 기한이 만료되거나 용량 한계에 도달하면 삭제

#### 디스크 성능 관련 유의사항

데이터 장기 보관에 대한 요구사항으로 인해 디스크 드라이브 활용하여 대량의 데이터 보관
회전식 디스크가 느린 것은 데이터 접근 패턴이 무작위일 때.
메시지 큐에서는 데이터 접근 패턴이 순차적이므로 충분히 적합한 성능 발휘.

현대적 운영체제는 디스크 데이터를 메모리에 아주 적극적으로 캐시
-> WAL도 OS가 제공하는 디스크 캐시 기능을 적극적으로 활용
