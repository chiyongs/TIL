# Redis 클러스터 사양

Redis Cluster에 대한 공식문서를 기반으로 번역해가며 공부하는 문서입니다.

## 디자인의 주요 속성 및 근거

### Redis 클러스터 목표

Redis 클러스터는 설계 시 중요도 순으로 다음과 같은 목표를 가진 Redis의 분산 구현입니다.

- 최대 1000개 노드까지 높은 성능과 선형 확장성을 제공합니다. 프록시가 없고, 비동기 복제가 사용되며, 값에 대한 병합 작업이 수행되지 않습니다.
- 허용 가능한 쓰기 안전 수준 : 시스템은 대부분의 마스터 노드에 연결된 클라이언트에서 발생하는 모든 쓰기를 (최선의 노력으로) 보존하려고 합니다. 일반적으로 확인된 쓰기가 손실될 수 있는 작은 윈도우(시간대)가 존재합니다. 클라이언트가 소수 파티션에 있을 때 확인된 쓰기가 손실되는 윈도우(시간대)가 더 큽니다.
- 가용성 : Redis 클러스터는 대부분의 마스터 노드에 접근 가능하고 더 이상 접근 불가능한 마스터 노드에 대해 접근 가능한 복제본이 하나 이상 존재하는 파티션에서도 작동할 수 있습니다. 또한 복제본 마이그레이션을 사용하면, 어떤 복제본에도 더 이상 복제되지 않는 마스터는 여러 복제본으로 구성된 마스터로부터 복제본을 받게 됩니다.
  (Redis 3.0 이상에서 구현되는 항목들)

### 구현된 하위 집합

Redis 클러스터는 비분산형 Redis 버전에서 사용 가능한 모든 단일 키 명령을 구현합니다. 집합, 합집합 및 교집합과 같은 복잡한 다중 키 연산을 수행하는 명령은 해당 연산에 관련된 모든 키가 동일한 슬롯에 해시되는 경우에 구현됩니다.
Redis 클러스터는 해시 태그라는 개념을 구현하는데, 이를 통해 특정 키가 동일한 해시 슬롯에 저장되도록 강제할 수 있습니다. 그러나 수동 리샤딩 중에는 단일 키 작업은 항상 사용 가능하지만 다중 키 작업은 한동안 사용할 수 없게 될 수 있습니다.
Redis 클러스터는 독립형 Redis 버전처럼 여러 데이터베이스를 지원하지 않습니다. 데이터베이스는 0번만 있으며, SELECT 명령은 허용되지 않습니다.

## Redis 클러스터 프로토콜의 클라이언트 및 서버 역할

Redis 클러스터에서 노드는 데이터를 보관하고 클러스터 상태를 가져오는 역할을 하며, 키를 올바른 노드에 매핑하는 작업도 수행합니다. 또한 클러스터 노드는 다른 노드를 자동으로 검색하고, 작동하지 않는 노드를 감지하고, 장애 발생 시에도 계속 작동할 수 있도록 필요에 따라 복제본 노드를 마스터 노드로 승격시킬 수 있습니다.

모든 클러스터 노드는 작업을 수행하기 위해 TCP 버스와 Redis 클러스터 버스라는 바이너리 프로토콜을 사용하여 연결됩니다. 각 노드는 클러스터 버스를 통해 클러스터의 다른 모든 노드와 연결됩니다. 노드는 가십 프로토콜을 사용하여 클러스터에 대한 정보를 전파하여 새 노드를 검색하고, 다른 모든 노드가 제대로 작동하는지 확인하기 위해 ping 패킷을 전송하고, 특정 상태를 알리는 데 필요한 클러스터 메시지를 전송합니다. 클러스터 버스는 또한 클러스터 전체에 Pub/sub 메시지를 전파하고 사용자의 요청 시 수동 장애 조치를 조정하는 데에도 사용합니다.
(수동 장애 조치는 Redis 클러스터 장애 감지기가 아닌 시스템 관리자가 직접 시작하는 장애 조치입니다.)

클러스터 노드는 요청을 프록시할 수 없으므로, 클라이언트는 -MOVED 및 -ASK 리다이렉션 오류를 사용하여 다른 노드로 리다이렉션될 수 있습니다. 클라이언트는 이론적으로 클러스터의 모든 노드에 요청을 보낼 수 있으며, 필요한 경우 리다이렉션되므로 클러스터 상태를 유지할 필요가 없습니다. 하지만 키와 노드 간의 맵을 캐시할 수 있는 클라이언트는 성능을 상당히 향상시킬 수 있습니다.

### 쓰기 안전

Redis 클러스터는 노드 간 비동기 복제를 사용하며, 마지막 장애 조치가 암묵적 병합 기능을 이깁니다. 즉, 마지막으로 선출된 마스터 데이터 세트가 결국 다른 모든 복제본을 대체합니다. 파티션 작업 중에 쓰기 데이터가 손실될 수 있는 시간대가 항상 존재합니다. 그러나 이러한 시간대는 다수의 마스터에 연결된 클라이언트와 소수의 마스터에 연결된 클라이언트의 경우 매우 다릅니다.

Redis 클러스터는 소수 쪽에서 수행된 쓰기보다 다수의 마스터에 연결된 클라이언트에서 수행된 쓰기를 더 많이 보존하려고 합니다. 다음은 장애 발생 시 다수 쪽 파티션에서 수신된 확인된 쓰기가 손실되는 시나리오의 예입니다.

1. 쓰기는 마스터에 도달할 수 있지만, 마스터가 클라이언트에 응답할 수는 있어도 마스터와 복제본 노드 간에 사용되는 비동기 복제를 통해 복제본에 전파되지 않을 수 있습니다. 쓰기가 복제본에 도달하지 않고 마스터가 종료되면, 마스터에 오랫동안 접속할 수 없어 복제본 중 하나가 승격되면 쓰기는 영구적으로 손실됩니다. 마스터 노드가 갑자기 완전히 고장난 경우에는 마스터가 클라이언트(쓰기 확인 응답)와 복제본(쓰기 전파)에 거의 동시에 응답하려고 하기 대문에 이러한 현상을 관찰하기 어렵습니다. 하지만 이는 현실 세계에서 발생하는 장애 케이스입니다.
2. 이론적으로 쓰기가 손실되는 다른 장애 케이스는 다음과 같습니다.

- 파티션으로 인해 마스터에 접근 불가
- 해당 마스터의 복제본 중 하나에 장애 발생
- 시간이 지난 후 마스터에 접속 가능성 존재
- 오래된 라우팅 테이블을 사용하는 클라이언트는 클러스터에서 새 마스터의 복제본으로 변환되기 전에 이전 마스터에 쓸 수 있는 가능성 존재

2번째 장애 케이스는 발생할 가능성이 낮습니다. 마스터 노드가 장애 조치를 수행할 만큼 충분한 시간 동안 다른 마스터 노드들과 통신할 수 없으면 더 이상 쓰기를 허용하지 않기 때문입니다. 파티션이 고정된 경우에도 다른 노드가 구성 변경 사항을 알릴 수 있도록 잠시 동안 쓰기가 거부됩니다. 또한 이 장애 케이스는 클라이언트의 라우팅 테이블이 아직 업데이트되지 않았음을 요구합니다.

파티션의 소수 그룹을 대상으로 하는 쓰기는 손실될 가능성이 더 큽니다. 예를 들어, Redis 클러스터는 소수 그룹의 마스터와 하나 이상의 클라이언트가 있는 파티션에서 상당한 수의 쓰기 손실을 발생시킵니다. 마스터가 다수 그룹에서 장애 조치될 경우 마스터로 전송된 모든 쓰기가 손실될 가능성이 있기 때문입니다.

특히 마스터가 장애조최되려면 적어도 NODE_TIMEOUT 동안 과반수의 마스터에 의해서 접근할 수 없는 상태가 되어야 하고, 그래서 만약 파티션이 그 시간 이전에 해소되면 쓰기의 손실은 없습니다. 파티션이 NODE_TIMEOUT 이상 지속될 때, NODE_TIMEOUT 시간까지 소수 측에서 실행된 모든 쓰기가 손실될 수도 있습니다. 그러나 소수 측의 Redis 클러스터는 NODE_TIMEOUT 이 경과하자마자, 과반수 측과의 연락없이 쓰기는 거절하기 시작하므로, 최대의 시간이 존재하며, 그 이후에는 소수 쪽은 더 이상 사용할 수 없는 상태가 됩니다. 이런 이유로 이 시간 이후에는 쓰기가 받아들여지거나, 손실되지도 않습니다.

### 가용성

Redis 클러스터는 파티션의 소수 측에서 사용할 수 없습니다. 파티션의 다수 측에 마스터의 과반수와 접근할 수 없는 모든 마스터에 대한 복제본이 있다고 가정할 때,
클러스터는 NODE_TIMEOUT 시간과 복제본이 선출되고 마스터를 페일오버하는 데 필요한 몇 초가 더 지나면 다시 사용할 수 있게 됩니다.
(페일오버는 일반적으로 1~2초 내에 실행됩니다.)

즉, Redis 클러스터는 클러스터 내 몇몇 노드의 장애를 견뎌내도록 설계되었지만, 대규모 네트워크 분할 발생 시 가용성이 필요한 애플리케이션에는 적합한 솔루션이 아닙니다.

각 노드에 단일 복제본이 있는 N개의 마스터 노드로 구성된 클러스터의 예에서 클러스터의 다수는 단일 노드가 분할되는 한 사용 가능한 상태를 유지하며, 두 개의 노드가 분할되는 경우에도 1 - (1/(N*2-1))의 확률로 사용 가능한 상태를 유지합니다.
(첫 번째 노드가 실패하면 총 N*2-1개의 노드가 남고 복제본이 없는 유일한 마스터가 실패할 확률은 1/(N\*2-1)입니다.)

예를 들어, 5개의 노드와 노드당 하나의 복제본이 있는 클러스터에서 두 개의 노드가 다수로부터 분할된 후 클러스터를 더 이상 사용할 수 없게 될 확률은 1/(5\*2-1) = 11.11% 입니다.

Redis 클러스터의 복제본 마이그레이션 기능 덕분에 복제본이 고아 마스터(더 이상 복제본이 없는 마스터)로 마이그레이션되므로 여러 실제 상황에서 클러스터 가용성이 향상됩니다. 따라서 모든 성공적인 장애 발생 시, 클러스터는 다음 장애에 더 잘 대처하기 위해 복제본 레이아웃을 재구성할 수 있습니다.

### 성능

Redis 클러스터에서는 노드가 주어진 키에 대한 책임을 맡고 있는 올바른 노드로 명령을 프록시하지 않고, 대신 키 공간의 주어진 부분을 담당하는 올바른 노드로 클라이언트를 리다이렉션합니다.

결국 클라이언트는 클러스터의 최신 상태와 어떤 노드가 어떤 키 하위 집합을 제공하는지 알게 되므로, 일반적인 작업 중에 클라이언트는 주어진 명령을 보내기 위해 올바른 노드에 직접 접속합니다.

비동기 복제를 사용하므로 노드는 다른 노드의 쓰기 확인을 기다리지 않습니다.
(WAIT 명령을 사용하여 명시적으로 요청하지 않은 경우)

또한, 다중 키 명령은 가까운 키에만 제한되므로 리샤딩을 제외하고는 노드 간에 데이터가 이동하지 않습니다.

일반 작업은 단일 Redis 인스턴스의 경우와 동일하게 처리됩니다. 즉, N개의 마스터 노드가 있는 Redis 클러스터에서는 설계가 선형적으로 확장됨에 따라 단일 Redis 인스턴스에 N을 곱한 것과 동일한 성능을 기대할 수 있습니다. 동시에, 클라이언트는 일반적으로 노드와 지속적인 연결을 유지하므로 쿼리는 일반적으로 단일 왕복으로 수행되므로 지연 시간 수치도 단일 독립형 Redis 노드의 경우와 동일합니다.

Redis 클러스터의 주요 목표는 약하지만 합리적인 형태의 데이터 안전성과 가용성을 유지하면서 매우 높은 성능과 확장성을 제공하는 것입니다.

### 병합 작업이 피해지는 이유

Redis 클러스터 설계는 여러 노드에서 동일한 키-값 쌍의 버전이 충돌하는 것을 방지합니다. Redis 데이터 모델의 경우, 이러한 충돌이 항상 바람직한 것은 아닙니다. Redis의 값은 종종 매우 크기 대문에 수백만 개의 요소가 있는 목록이나 정렬된 집합을 흔히 볼 수 있습니다. 또한 데이터 유형은 의미적으로 복잡합니다. 이러한 종류의 값을 전송하고 병합하는 것은 심각한 병목 현상을 초래할 수 있으며, 애플리케이션 측 로직, 메타데이터 저장을 위한 추가 메모리 등이 필요할 수 있습니다.

여기에는 엄격한 기술적 제한이 없습니다. CRDT 또는 동기 복제 상태 머신은 Redis와 유사한 복잡한 데이터 유형을 모델링할 수 있습니다. 그러나 이러한 시스템의 실제 런타임 동작은 Redis 클러스터와 유사하지 않습니다. Redis 클러스터는 비클러스터형 Redis 버전의 정확한 사용 사례를 포괄하도록 설계되었습니다.

## Redis 클러스터 주요 구성 요소 개요

### 키 배포 모델

클러스터의 키 공간은 16,384개 슬롯으로 분할되어 클러스터 크기에 최대 16,384개의 마스터 노드를 설정할 수 있습니다.
(그러나 제안되는 최대 노드 크기는 약 1,000개 노드 정도입니다.)

클러스터의 각 마스터 노드는 16,384개 해시 슬롯의 하위 집합을 처리합니다. 클러스터 재구성(즉, 해시 슬롯이 한 노드에서 다른 노드로 이동하는 경우)이 진행 중이지 않을 때 클러스터는 안정적입니다. 클러스터가 안정적일 때, 단일 노드는 단일 해시 슬롯을 처리합니다. (단, 서비스 노드는 네트워크 분할이나 장애 발생 시 이를 대체할 하나 이상의 복제본을 가질 수 있으며, 이는 오래된 데이터를 읽어도 되는 읽기 작업의 확장에 사용될 수 있습니다.)

키를 해시 슬롯에 매핑하는 데 사용되는 기본 알고리즘은 다음과 같습니다.
`HASH_SLOT = CRC16(key) mod 16384`
테스트 결과, CRC16은 16384개 슬롯에 다양한 종류의 키를 균등하게 분배하는 데 매우 뛰어난 성능을 보였습니다.

### 해시태그

해시 태그를 구현하는 데 사용되는 해시 슬롯 계산에는 예외가 있습니다. 해시 태그는 여러 키가 동일한 해시 슬롯에 할당되도록 보장하는 방법입니다. 이는 Redis 클러스터에서 다중 키 작업을 구현하는 데 사용됩니다.

해시태그를 구현하기 위해 특정 조건에서 키의 해시 슬롯은 약간 다른 방식으로 계산됩니다. 키에 "{...}" 패턴이 포함된 경우, { 와 } 사이의 부분 문자열만 해시하여 해시 슬롯을 얻습니다. 그러나 { 또는 } 가 여러 번 나타날 수 있으므로, 알고리즘은 다음 규칙에 따라 잘 정의됩니다.

- 키에 { 문자가 포함되어 있는 경우
- 그리고 { 오른쪽에 } 문자가 있는 경우
- 그리고 {의 첫 번째 발생과 }의 첫 번째 발생 사이에 하나 이상의 문자가 있는 경우

그런 다음 키를 해시하는 대신 {의 첫 번째 발생과 그 다음에 }의 첫 번째 발생 사이에 있는 것만 해시합니다.

예시:

- {user1000}.following과 {user1000}.followers 두 키는 해시 슬롯을 계산하기 위해 문자열 user1000만 해시되므로 동일한 해시 슬롯에 해시됩니다.
- foo{}{bar} 키의 경우, 첫 번째 { 다음에 오른쪽에 }가 나오고 가운데 문자가 없으므로 전체 키가 평소처럼 해시됩니다.
- foo{{bar}}zap 키의 경우, 첫 번째 {와 오른쪽에 첫 번째 } 사이에 있는 하위 문자열인 {bar가 해시됩니다.
- foo{bar}{zap} 키의 경우, 알고리즘이 {와 }의 첫 번째 유효 또는 유효하지 않은 일치에서 멈추므로 부분 문자열 bar가 해시됩니다.
- 이 알고리즘에 따르면 키가 {}로 시작하면 전체 키가 해시됩니다. 이는 이진 데이터를 키 이름으로 사용할 때 유용합니다.

### 글로브 스타일 패턴

KEYS, SCAN, SORT 등 글로벌 스타일 패턴을 사용하는 명령은 단일 슬롯을 의미하는 패턴에 최적화됩니다. 즉, 패턴과 일치할 수 있는 모든 키가 특정 슬롯에 속해야 하는 경우, 해당 슬롯에서만 패턴과 일치하는 키를 검색하빈다. 패턴 슬롯 최적화는 Redis 8.0에 도입되었습니다.

패턴이 다음 조건을 충족하면 최적화가 시작됩니다.

- 패턴에는 해시태그가 포함되어 있고,
- 해시태그 앞에 와일드카드나 이스케이프 문자가 없으며,
- 중괄호 안의 해시태그에 와일드카드나 이스케이프 문자가 포함되어 있지 않습니다.

예를 들어, SCAN 0 MATCH {abc}_는 해시태그를 성공적으로 인식하고 abc에 해당하는 슬롯만 스캔합니다. 그러나 _{abc}, {a\*c} 또는 {a\*bc} 패턴은 해시태그를 인식할 수 없으므로 모든 슬롯을 스캔해야 합니다.

### 클러스터 노드 속성

클러스터에서 각 노드는 고유한 이름을 갖습니다. 노드 이름은 160비트 난수를 16진수로 표현한 것으로, 노드가 처음 시작될 때(일반적으로 /dev/urandom을 사용하여) 생성됩니다. 노드는 노드 설정 파일에 ID를 저장하며, 시스템 관리자가 노드 설정 파일을 삭제하거나 CLUSTER RESET 명령을 통해 하드 리셋을 요청하지 않는 한 영구적으로 동일한 ID를 사용합니다.

노드 ID는 전체 클러스터의 모든 노드를 식별하는 데 사용됩니다. 특정 노드는 노드 ID를 변경하지 않고도 IP 주소를 변경할 수 있습니다. 또한 클러스터는 IP/포트 변경을 감지하고 클러스터 버스에서 실행되는 가십 프로토콜을 사용하여 재구성할 수 있습니다.

노드 ID는 각 노드와 관련된 유일한 정보는 아니지만, 항상 전역적으로 일고나된 유일한 정보입니다. 모든 노드에는 다음과 같은 관련 정보 집합이 있습니다. 일부 정보는 이 특정 노드의 클러스터 구성 세부 정보에 대한 것이며, 궁극적으로 클러스터 전체에서 일관성을 유지합니다. 마지막으로 노드에 ping이 전송된 시간과 같은 다른 정보는 각 노드에 로컬로 저장됩니다.

각 노드는 클러스터에서 알고 있는 다른 노드에 대한 다음 정보를 유지 관리합니다. 노드 ID, 노드 IP 및 포트, 플래그 세트, 복제본으로 플래그가 지정된 경우 노드의 마스터, 노드에 ping을 보낸 마지막 시간과 pong을 받은 마지막 시간, 노드의 현재 구성 에포크, 링크 상태 및 마지막으로 제공된 해시 슬롯 세트입니다.

모든 노드 필드에 대한 자세한 설명은 CLUSTER NODES 설명서에 나와 있씁니다.

CLUSTER NODES 명령은 클러스터의 모든 노드로 전송될 수 있으며, 쿼리된 노드가 클러스터에 대해 가지고 있는 로컬 뷰에 따라 클러스터의 상태와 각 노드에 대한 정보를 제공합니다.

다음은 세 개의 노드로 구성된 소규모 클러스의 마스터 노드로 전송된 CLUSTER NODES 명령의 샘플 출력입니다.

```
$ redis-cli cluster nodes
d1861060fe6a534d42d8a19aeb36600e18785e04 127.0.0.1:6379 myself - 0 1318428930 1 connected 0-1364
3886e65cc906bfd9b1f7e7bde468726a052d1dae 127.0.0.1:6380 master - 1318428930 1318428931 2 connected 1365-2729
d289c575dcbc4bdd2931585fd4339089e461a27d 127.0.0.1:6381 master - 1318428931 1318428931 3 connected 2730-4095
```

위 목록에는 노드 ID, 주소:포트, 플래그, 마지막 ping 수신 시간, 구성 에포크, 링크 상태, 슬롯 등 다양한 필드가 순서대로 나열되어 있습니다. 위 필드에 대한 자세한 내용은 Redis 클러스터의 특정 부분을 살펴보는 즉시 설명하겠습니다.

### 클러스터 버스

모든 Redis 클러스터 노드에는 다른 Redis 클러스터 노드에서 들어오는 연결을 수신하기 위한 추가 TCP 포트가 있습니다. 이 포트는 데이터 포트에 10000을 더하여 생성되거나 cluster-port 설정으로 지정할 수 있습니다.

예시 1:
Redis 노드가 포트 6379에서 클라이언트 연결을 수신하고 redis.conf에 cluster-port 매개변수를 추가하지 않으면 클러스터 버스 포트가 16379가 열립니다.

예시 2:
Redis 노드가 포트 6379에서 클라이언트 연결을 수신하고 redis.conf에서 cluster-port 20000을 설정하면 클러스터 버스 포트 20000이 열립니다.

노드 간 통신은 클러스터 버스와 클러스터 버스 프로토콜(다양한 유형과 크기의 프레임으로 구성된 바이너리 프로토콜)을 통해서만 이루어집니다. 클러스터 버스 바이너리 프로토콜은 외부 소프트웨어 장치가 이 프로토콜을 사용하여 Redis 클러스터 노드와 통신하도록 설계되지 않았기 때문에 공개적으로 문서화되어 있지 않습니다. 하지만 Redis 클러스터 소스 코드와 파일 cluster.h와 cluster.c 파일을 통해 클러스터 버스 프로토콜에 대한 자세한 내용을 확인할 수 있습니다.

### 클러스터 토폴로지

Redis 클러스터는 모든 노드가 TCP 연결을 사용하여 다른 모든 노드와 연결된 전체 메시입니다.
N개의 노드로 구성된 클러스터에서 각 노드는 N-1개의 나가는 TCP 연결과 N-1개의 들어오는 연결을 갖습니다.
이러한 TCP 연결은 항상 활성 상태로 유지되며 필요에 따라 생성되지 않습니다. 노드가 클러스터 버스에서 ping에 대한 응답으로 pong 응답을 기다리는 경우, 노드를 도달 불가능으로 표시할 만큼 충분히 기다리기 전에 처음부터 다시 연결하여 노드와의 연결을 새로 고치려고 시도합니다.
Redis 클러스터 노드는 전체 메시를 형성하지만, 노드는 일반 조건에서 노드 간에 너무 많은 메시지를 교환하는 것을 피하기 위해 가십 프로토콜과 구성 업데이트 메커니즘을 사용하므로 교환되는 메시지 수는 기하급수적으로 증가하지 않습니다.

### 노드 핸드셰이크

노드는 항상 클러스터 버스 포트에서 연결을 수락하고, ping을 보내는 노드가 신뢰할 수 없는 경우에도 ping을 수신하면 응답합니다. 그러나 송신 노드가 클러스터의 일부로 간주되지 않으면 수신 노드는 다른 모든 패킷을 삭제합니다.

노드는 두 가지 방법으로만 다른 노드를 클러스터의 일부로 허용합니다.

- 노드가 MEET 메시지(CLUSTER MEET 명령)를 전송하는 경우입니다. MEET 메시지는 PING 메시지와 완전히 동일하지만, 수신자가 노드를 클러스터의 일부로 수락하도록 강제합니다. 노드는 시스템 관리자가 다음 명령을 통해 요청하는 경우에만 다른 노드에 MEET 메시지를 전송합니다.
  CLUSTER MEET ip port
- 이미 신뢰되는 노드가 다른 노드에 대해 정보를 공유하는 경우, 노드는 해당 노드를 클러스터의 일부로 등록합니다. 따라서 A가 B를 알고 B가 C를 알고 있다면, 결국 B는 A에게 C에 대한 정보를 공유합니다. 이 경우, A는 C를 네트워크의 일부로 등록하고 C와의 연결을 시도합니다.

즉, 연결된 그래프의 노드를 연결하면 결국 완전히 연결된 그래프가 자동으로 형성됩니다. 즉, 클러스터는 다른 노드를 자동으로 검색할 수 있지만, 시스템 관리자가 강제로 신뢰 관계를 설정한 경우에만 가능합니다.

이 메커니즘은 클러스터를 더욱 강력하게 만들지만 IP 주소 변경이나 기타 네트워크 관련 이벤트 후에 서로 다른 Redis 클러스터가 실수로 혼합되는 것을 방지합니다.

## 리다이렉션 및 리샤딩

### MOVED 리다이렉션

Redis 클라이언트는 복제 노드를 포함하여 클러스터의 모든 노드에 쿼리를 자유롭게 전송할 수 있습니다. 노드는 쿼리를 분석하고, 쿼리가 허용 가능한 경우(즉, 쿼리에 키가 하나만 언급되었거나 언급된 여러 키가 모두 동일한 해시 슬롯에 있는 경우) 해당 키가 속한 해시 슬롯을 담당하는 노드를 찾습니다.

해시 슬롯이 노드에 의해 제공되는 경우 쿼리는 간단히 처리되고, 그렇지 않은 경우 노드는 내부 해시 슬롯과 노드 맵을 확인하고 다음 예와 같이 MOVED 오류로 클라이언트에 응답합니다.

```
GET x
-MOVED 3999 127.0.0.1:6381
```

오류에는 키의 해시 슬롯(3999)과 쿼리를 처리할 수 있는 인스턴스의 엔트포인트:포트가 포함됩니다. 클라이언트는 지정된 노드의 엔드포인트 주소와 포트로 쿼리를 다시 실행해야 합니다. 엔드포인트는 IP 주소, 호스트 이름 또는 비어 있을 수 있습니다(예: -MOVED 3999 :6380). 비어있는 엔드포인트는 서버 노드에 알 수 없는 엔드포인트가 있음을 나타내며, 클라이언트는 다음 요청을 현재 요청과 동일한 엔드포인트로 보내되 제공된 포트를 사용해야 합니다.

클라이언트가 쿼리를 다시 실행하기 전에 오랜 시간 대기하고, 그 사이에 클러스터 구성이 변경된 경우에도, 해시 슬롯 3999가 다른 노드에서 처리되고 있다면 대상 노드는 MOVED 오류로 다시 응답합니다. 접속된 노드에 업데이트된 정보가 없는 경우에도 마찬가지입니다.

따라서 클러스터 관점에서 노드는 ID로 식별되지만, 해시 슬롯과 엔드포인트:포트 쌍으로 식별되는 Redis 노드 간의 맵만 노출하여 클라이언트와의 인터페이스를 단순화하려고 합니다.

클라이언트는 반드시 그럴 필요는 없지만, 해시 슬롯 3999가 127.0.0.1:6381에 의해 처리된다는 것을 기억해야 합니다. 이렇게 하면 새 명령을 실행해야 할 때 대상 키의 해시 슬롯을 계산하여 올바른 노드를 선택할 가능성을 높일 수 있습니다.

대안은 MOVED 리다이렉션이 수신될 때 CLUSTER SHARDS 명령이나 더 이상 사용되지 않는 CLUSTER SLOTS 명령을 사용하여 전체 클라이언트 측 클러스터 레이아웃을 새로 고치는 것입니다. 리다이렉션이 발생하면 슬롯이 하나만 재구성된 것이 아니라 여러 개가 재구성되었을 가능성이 높으므로, 클라이언트 구성을 가능한 한 빨리 업데이트하는 것이 가장 좋은 전략입니다.

클러스터가 안정적일 때(구성에 지속적인 변경이 없을 때) 모든 클라이언트가 해시 슬롯 -> 노드 맵을 얻게 되므로 클라이언트가 리다이렉션, 프록시 또는 기타 단일 장애 지점 엔터티 없이 올바른 노드에 직접 주소를 지정할 수 있어 클러스터가 효율적이 됩니다.

클라이언트는 이 문서의 뒷부분에서 설명하는 -ASK 리다이렉션도 처리할 수 있어야 합니다. 그렇지 않으면 완전한 Redis 클러스터 클라이언트가 아닙니다.

### 라이브 재구성

Redis 클러스터는 클러스터가 실행되는 동안 노드를 추가하고 제거하는 기능을 지원합니다. 노드 추가 또는 제거는 동일한 작업, 즉 한 노드에서 다른 노드로 해시 슬롯을 이동하는 작업으로 추상화됩니다. 즉, 클러스터 재조정, 노드 추가 또는 제거 등에 동일한 기본 매커니즘을 사용할 수 있습니다.

- 클러스터에 새 노드를 추가하려면 빈 노드를 클러스터에 추가하고 일부 해시 슬롯 세트를 기존 노드에서 새 노드로 이동합니다.
- 클러스터에서 노드를 제거하려면 해당 노드에 할당된 해시 슬롯을 다른 기존 노드로 이동합니다.
- 클러스터의 균형을 재조정하려면 주어진 해시 슬롯 세트를 노드 간에 이동합니다.

구현의 핵심은 해시 슬롯을 이동할 수 있는 기능입니다. 실용적인 관점에서 해시 슬롯은 키 집합일 뿐이므로, Redis 클러스터가 리샤딩 중에 실제로 하는 일은 한 인스턴스에서 다른 인스턴스로 키를 이동하는 것입니다. 해시 슬롯을 이동한다는 것은 해시되는 모든 키를 해당 해시 슬롯으로 이동하는 것을 의미합니다.

이것이 어떻게 작동하는지 이해하려면 Redis 클러스터 노드에서 슬롯 변환 테이블을 조작하는데 사용되는 CLUSTER 하위 명령을 보여줘야 합니다.

다음 하위 명령을 사용할 수 있습니다. (유용하지 않은 명령 포함)

- CLUSTER ADDSLOTS slot1 [slot2] ... [slotN]
- CLUSTER DELSLOTS slot1 [slot2] ... [slotN]
- CLUSTER ADDSLOTSRANGE start-slot1 end-slot1 [start-slot2 end-slot2] ... [start-slotN end-slotN]
- CLUSTER DELSLOTSRANGE start-slot1 end-slot1 [start-slot2 end-slot2] ... [start-slotN end-slotN]
- CLUSTER SETSLOT slot NODE node
- CLUSTER SETSLOT slot MIGRATING node
- CLUSTER SETSLOT slot IMPORTING node

처음 네 개의 명령인 ADDSLOTS, DELSLOTS, ADDSLOTSRANGE, DELSLOTSRANGE는 Redis 노드에 슬롯을 할당(또는 제거)하는데 사용됩니다.
슬롯을 할당한다는 것은 특정 마스터 노드에게 지정된 해시 슬롯의 컨텐츠를 저장하고 제공할 책임을 부여하는 것을 의미합니다.

해시 슬롯이 할당되면 나중에 구성 전파 섹션에서 설명하는 것처럼 가십 프로토콜을 사용하여 클러스터 전체에 전파됩니다.

ADDSLOTS 및 ADDSLOTSRANGE 명령은 일반적으로 새 클러스터를 처음부터 생성할 때 각 마스터 노드에 사용 가능한 16,384개의 해시 슬롯 중 일부를 할당하는 데 사용됩니다.

DELSLOTS와 DELSLOTSRANGE 는 주로 클러스터 구성을 수동으로 수정하거나 디버깅하는 데 사용되며, 실제로는 거의 사용되지 않습니다.

SETSLOT 하위 명령은 SELSLOT <슬롯> NODE 형식을 사용하는 경우 특정 노드 ID에 슬롯을 할당하는 데 사용됩니다. 그렇지 않은 경우 슬롯은 두 가지 특수 상태인 MIGRATING과 IMPORTING으로 설정할 수 있습니다. 이 두 가지 특수 상태는 해시 슬롯을 한 노드에서 다른 노드로 마이그레이션하는 데 사용됩니다.

- 슬롯이 MIGRATING으로 설정되면 노드는 해당 해시 슬롯에 대해서 해당 키가 존재하는 경우에만 쿼리를 수락합니다. 그렇지 않으면 -ASK 리다이렉션을 사용하여 마이그레이션 대상 노드로 쿼리를 전달합니다.
- 슬롯이 IMPORTING으로 설정되면 요청 앞에 ASKING 명령이 있는 경우에만 노드는 해당 해시 슬롯에 대한 쿼리를 허용합니다. 클라이언트가 ASKING 명령을 전달하지 않은 경우, 쿼리는 일반적인 경우처럼 -MOVED 리다이렉션 오류를 통해 실제 해시 슬롯 소유자에게 리다이렉션됩니다.

해시 슬롯 마이그레이션의 예를 통해 이를 더 명확하게 설명해보겠습니다. A와 B라는 두 개의 Redis 마스터 노드가 있다고 가정해보겠습니다. 해시 슬롯 8을 A에서 B로 이동하려면 다음과 같은 명령을 실행합니다.

- We send B : CLUSTER SETSLOT 8 IMPORTING A
- We send A : CLUSTER SETSLOT 8 MIGRATING B

다른 모든 노드는 해시 슬롯 8에 속한 키로 쿼리될 때마다 클라이언트는 노드 "A"로 계속 연결합니다. 따라서 다음과 같은 상황이 발생합니다.

- 기존 키에 대한 모든 쿼리는 "A"에서 처리됩니다.
- A에 존재하지 않는 키에 대한 모든 쿼리는 "B"에서 처리됩니다. "A"는 클라이언트를 "B"로 리다이렉션하기 때문입니다.

이렇게 하면 "A"에 더 이상 새 키를 생성하지 않습니다. 그동안 리샤딩 및 Redis 클러스터 구성 중에 사용되는 redis-cli는 해시 슬롯 8에 있는 기존 키를 A에서 B로 마이그레이션합니다. 이 작업은 다음 명령을 사용하여 수행됩니다.

```
CLUSTER GETKEYSINSLOT slot count
```

위 명령은 지정된 해시 슬롯에서 count 개의 키를 반환합니다. 반환된 키에 대해 redis-cli는 노드 "A"에 MIGRATE 명령을 전송합니다. 이 명령은 지정된 키를 A에서 B로 원자적으로 마이그레이션합니다. (두 인스턴스 모두 키 마이그레이션에 필요한 시간(보통 매우 짧은 시간) 동안 잠기므로 경합 조건이 발생하지 않습니다.) MIGRATE의 작동 방식은 다음과 같습니다.

```
MIGRATE target_host target_port "" target_database id timeout KEYS key1 key2 ...
```

MIGRATE는 대상 인스턴스에 연결하고 직렬화된 버전의 키를 전송하며, OK 코드가 수신되면 자체 데이트세트의 이전 키가 삭제됩니다. 외부 클라이언트 관점에서 키는 언제든지 A 또는 B에 존재합니다.

Redis 클러스터에서 0 이외의 데이터베이스를 지정할 필요가 없지만, MIGRATE는 Redis 클러스터와 관련 없는 다른 작업에 사용할 수 있는 일반적인 명령입니다. MIGRATE는 긴 목록과 같은 복잡한 키를 이동할 때에도 최대한 빠르게 실행되도록 최적화되어 있습니다. 하지만 Redis 클러스터에서 데이터베이스를 사용하는 애플리케이션에 지연 시간 제약이 있는 경우 큰 키가 있는 클러스터를 재구성하는 것은 현명한 절차가 아닙니다.

마이그레이션 프로세스가 최종적으로 완료되면, SETSLOT <슬롯> NODE <노드 ID> 명령이 마이그레이션에 관련된 두 노드로 전송되어 슬롯을 다시 정상 상태로 설정합니다. 일반적으로 동일한 명령이 다른 모드 노드에도 전송되는데, 이는 새 구성이 클러스터 전체에 자연스럽게 전파될 때까지 기다리지 않기 위해서입니다.

### ASK 리다이렉션

이전 섹션에서 ASK 리다이렉션에 대해 간략하게 설명했습니다. 왜 MOVED 리다이렉션을 그냥 사용할 수 없을까요? MOVED는 해시 슬롯이 다른 노드에 의해 영구적으로 처리된다고 생각하고 다음 쿼리를 지정된 노드에 대해 시도해야 한다는 것을 의미하지만, ASK는 다음 쿼리만 지정된 노드로 전송한다는 것을 의미합니다.

이 작업이 필요한 이유는 해시 슬롯 8에 대한 다음 쿼리가 A에 아직 남아 있는 키에 대한 것일 수 있기 때문입니다. 따라서 클라이언트가 항상 A를 시도한다음 필요한 경우 B를 시도하도록 해야 합니다. 이 작업은 사용 가능한 16,384개 해시 슬롯 중 하나에 대해서만 수행되므로 클러스터 성능 저하가 허용 가능합니다.

클라이언트의 동작을 강제로 실행해야 하므로, 클라이언트가 노드 A를 시도한 후에만 노드 B를 시도하도록 하고, 클라이언트가 쿼리를 보내기 전에 ASKING 명령을 보낸 경우 노드 B는 IMPORTING으로 설정된 슬롯의 쿼리만 허용합니다.

기본적으로 ASKING 명령은 클라이언트에 일회성 플래그를 설정하여 노드가 IMPORTING 슬롯에 대한 쿼리를 제공하도록 강제합니다.

클라이언트 관점에서 ASK 리다이렉션의 전체 의미는 다음과 같습니다.

- ASK 리다이렉션을 수신하면 지정된 노드로 리다이렉션된 쿼리만 전송하고 이후 쿼리는 이전 노드로 계속 전송합니다.
- ASKING 명령으로 리다이렉션된 쿼리를 시작합니다.
- 아직 로컬 클라이언트 테이블을 업데이트하여 해시 슬롯 8을 B에 매핑하지 마세요.

해시 슬롯 8의 마이그레이션이 완료되면 A는 MOVED 메시지를 전송하고 클라이언트는 해시 슬롯 8을 새 엔드포인트 및 포트 쌍에 영구적으로 매핑할 수 있습니다. 버그가 있는 클라이언트가 매핑을 더 일찍 수행하더라도 쿼리를 실행하기 전에 ASKING 명령을 전송하지 않으므로 문제가 되지 않습니다. 따라서 B는 MOVED 리다이렉션 오류를 사용하여 클라이언트를 A로 리다이렉션합니다.

슬롯 마이그레이션은 CLUSTER SETSLOT 명령어 설명서에서 비슷한 용어로 설명되어 있지만 (설명서의 중복을 위해) 다른 표현을 사용하고 있습니다.

### 클라이언트 연결 및 리다이렉션 처리

효율성을 위해 Redis 클러스터 클라이언트는 현재 슬롯 구성 맵을 유지합니다. 하지만 이 구성이 최신 상태일 필요는 없습니다. 잘못된 노드에 접속하여 리다이렉션이 발생하는 경우, 클라이언트는 내부 슬롯 맵을 적절하게 업데이트할 수 있습니다.

클라이언트는 일반적으로 두 가지 다른 상황에서 슬롯과 매핑된 노드 주소의 전체 목록을 가져와야 합니다.

- 시작 시 초기 슬롯 구성을 채우려면
- 클라이언트가 MOVED 리다이렉션을 수신할 때

클라이언트는 테이블에서 이동된 슬롯만 업데이트하여 MOVED 리다이렉션을 처리할 수 있습니다. 하지만 이는 여러 슬롯의 구성이 동시에 수정되는 경우가 많기 대문에 일반적으로 효율적이지 않습니다. 예를 들어, 복제본이 마스터로 승격되면 이전 마스터에서 처리하던 모든 슬롯이 다시 매핑됩니다. MOVED 리다이렉션에 대응하려면 슬롯의 전체 맵을 노드로 처음부터 가져오는 것이 훨씬 간단합니다.

클라이언트는 CLUSTER SLOTS 명령을 실행하여 슬롯 범위 배열과 지정된 범위를 제공하는 관련 마스터 및 복제 노드를 검색할 수 있습니ㅏㄷ.

다음은 CLUSTER SLOTS 출력의 예입니다.

```
127.0.0.1:7000> cluster slots
1) 1) (integer) 5461
   2) (integer) 10922
   3) 1) "127.0.0.1"
      2) (integer) 7001
   4) 1) "127.0.0.1"
      2) (integer) 7004
2) 1) (integer) 0
   2) (integer) 5460
   3) 1) "127.0.0.1"
      2) (integer) 7000
   4) 1) "127.0.0.1"
      2) (integer) 7003
3) 1) (integer) 10923
   2) (integer) 16383
   3) 1) "127.0.0.1"
      2) (integer) 7002
   4) 1) "127.0.0.1"
      2) (integer) 7005
```

반환된 배열의 각 요소의 처음 두 하위 요소는 슬롯 범위의 시작 및 종료입니다. 추가 요소는 주소-포트 쌍을 나타냅니다. 첫 번째 주소-포트 쌍은 해당 슬롯을 제공하는 마스터이고, 추가된 주소-포트 쌍은 동일한 슬롯을 제공하는 복제본입니다. 복제본은 오류 상태가 아닐 때(즉, FAIL 플래그가 설정되지 않은 경우)에만 나열됩니다.

위 출력의 첫 번째 요소는 5461에서 10922까지의 슬롯(시작 및 끝 포함)이 127.0.0.1:7001에서 제공되고 127.0.0.1:7004에서 복제본이 접촉하여 읽기 전용 부하를 확장할 수 있음을 나타냅니다.

클러스터가 잘못 구성된 경우 CLUSTER SLOTS는 16,384개의 슬롯 전체를 포함하는 범위를 반환하지 않을 수 있으므로, 클라이언트는 대상 노드를 NULL로 채워 슬롯 구성 맵을 초기화하고, 사용자가 할당되지 않은 슬롯에 속한 키에 대한 명령을 실행하려고 하면 오류를 보고해야 합니다.

슬롯이 할당되지 않은 것으로 확인되면 호출자에게 오류를 반환하기 전에, 클라이언트는 슬롯 구성을 다시 가져와 클러스터가 올바르게 구성되었는지 확인해야 합니다.

### 다중 키 작업

해시태그를 사용하면 클라이언트는 다중 키 연산을 자유롭게 사용할 수 있습니다. 예를 들어 다음 연산은 유효합니다.

```
MSET {user:1000}.name Angela {user:1000}.surname White
```

해시 슬롯의 재분할이 진행 중이면 다중 키 작업을 사용할 수 없게 될 수 있습니다.

더 구체적으로 말하면, 재분할 중에도 모든 키가 존재하고 모두 동일한 슬롯(소스 또는 대상 노드)에 해시되어 있는 다중 키 작업은 계속 사용할 수 있습니다.

존재하지 않거나 재분할 중에 소스 노드와 대상 노드 간에 분할된 키에 대한 작업은 -TRYAGAIN 오류를 생성합니다. 클라이언트는 잠시 후 작업을 시도하거나 오류를 보고할 수 있습니다.

지정된 해시 슬롯의 마이그레이션이 종료되면 해당 해시 슬롯에서 모든 다중 키 작업을 다시 사용할 수 있습니다.

### 복제 노드를 사용하여 읽기 확장

일반적으로 복제 노드는 클라이언트를 지정된 명령에 관련된 해시 슬롯의 권한 있는 마스터로 리다이렉션하지만, 클라이언트는 복제본을 사용하여 READONLY 명령을 사용하여 읽기를 확장할 수 있습니다.

READONLY는 Redis 클러스터 복제 노드에 클라이언트가 오래된 데이터를 읽어도 괜찮으며 쓰기 쿼리를 실행할 생각이 없음을 알립니다.

연결이 읽기 전용 모드일 때, 클러스터는 복제본의 마스터 노드에서 제공하지 않는 키가 작업에 포함된 경우에만 클라이언트로 리다이렉션을 전송합니다. 이는 다음과 같은 이유로 발생할 수 있습니다.

1. 클라이언트가 이 복제본의 마스터가 처리한 적이 없는 해시 슬롯에 대한 명령을 보냈습니다.
2. 클러스터가 재구성되었고 복제본은 더 이상 주어진 해시 슬롯에 대한 명령을 제공할 수 없습니다.

이런 일이 발생하면 클라이언트는 이전 섹션에서 설명한 대로 해시 슬롯 맵을 업데이트해야 합니다.

연결의 읽기 전용 상태는 READWRITE 명령을 사용하여 지울 수 있습니다.

## 내결함성

### 하트비트와 가십 메시지

Redis 클러스터 노드는 ping 패킷과 pong 패킷을 지속적으로 교환합니다. 이 두 종류의 패킷은 동일한 구조를 가지며, 둘 다 중요한 구성 정보를 전달합니다. 유일한 차이점은 메시지 유형 필드입니다. ping 패킷과 pong 패킷의 합은 하트비트 패킷이라고 합니다.

일반적으로 노드는 ping 패킷을 전송하고, 수신자는 이를 통해 pong 패킷으로 응답합니다. 하지만 반드시 그런 것은 아닙니다. 노드가 pong 패킷을 전송하여 다른 노드에 응답을 트리거하지 않고 자신의 구성에 대한 정보를 전송할 수도 있습니다. 이는 예를 들어 새로운 구성을 가능한 한 빨리 브로드캐스트하는 데 유용합니다.

일반적으로 노드는 매초 몇 개의 무작위 노드에 ping을 보내므로 클러스터에 있는 노드 수에 관계없이 각 노드에서 보낸 ping 패킷의 총 수(및 받은 pong 패킷의 총 수)가 일정한 양입니다.

하지만 모든 노드는 NODE_TIMEOUT 시간의 절반 이상 ping을 보내거나 pong을 받지 않은 다른 모든 노드에 ping을 보냅니다. NODE_TIMEOUT이 경과하기 전에 노드는 현재 TCP 연결에 문제가 있다는 이유만으로 노드가 도달 불가능한 것으로 간주되지 않도록 다른 노드와 TCP 링크를 다시 연결하려고 시도합니다.

NODE_TIMEOUT을 작은 숫자로 설정하고 노드 수(N)를 매우 크게 설정하면 전역적으로 교환되는 메시지 수가 상당히 많아질 수 있습니다. 각 노드는 NODE_TIMEOUT 시간의 절반마다 최신 정보가 없는 다른 모든 노드에 ping을 시도하게 됩니다.

예를 들어, 노드 제한 시간이 60초로 설정된 100개 노드 클러스터에서 각 노드는 30초마다 99개의 ping을 보내려고 하며, 이는 초당 총 3.3개의 ping이 됩니다. 100개 노드를 곱하면 전체 클러스터에서 초당 330개의 ping이 전송됩니다.

메시지 수를 줄이는 방법은 있지만, Redis 클러스터 장애 감지에 사용되는 대역폭과 관련된 문제는 보고되지 않았습니다. 따라서 현재로서는 명확하고 직접적인 설계를 사용하고 있습니다. 위 예시에서도 초당 330개의 패킷이 100개의 노드에 균등하게 분배되므로 각 노드가 수신하는 트래픽을 허용 가능합니다.

### 하트비트 패킷 내용

핑앤퐁 패킷에는 모든 유형의 패킷에 공통적인 헤더(예: 장애 조치 투표를 요청하는 패킷)와 핑앤퐁 패킷에만 해당하는 특별한 가십 섹션이 포함되어 있습니다.

공통 헤더에는 다음과 같은 정보가 있습니다.

- 노드 ID는 160비트의 의사난수 문자열로, 노드가 처음 생성될 때 지졍되며 Redis 클러스터 노드의 수명 동안 동일하게 유지됩니다.
- Redis 클러스터에서 사용하는 분산 알고리즘을 마운트하는 데 사용되는 전송 노드의 필드 currentEpoch와 configEpoch필드입니다(다음 섹션에서 자세히 설명합니다). 노드가 복제본인 경우 configEpoch는 마스터 노드의 마지막으로 알려진 configEpoch입니다.
- 노드 플래그는 노드가 복제본인지, 마스터인지, 그리고 기타 단일 비트 노드 정보를 나타냅니다.
- 전송 노드에서 제공하는 해시 슬롯의 비트맵입니다. 노드가 복제본인 경우 마스터에서 제공하는 슬롯의 비트맵입니다.
- Redis가 클라이언트 명령을 수신하는 데 사용하는 전송자 TCP 기본 포트입니다.
- Redis가 노드 간 통신에 사용하는 클러스터 포트입니다.
- 전송자 관점에서 본 클러스트이 상태(다운 또는 정상)입니다.
- 전송 노드가 복제본인 경우 해당 전송 노드의 마스터 노드 ID입니다.

핑퐁 패킷에는 가십 섹션도 포함되어 있습니다. 이 섹션은 수신자에게 송신 노드가 클러스터 내 다른 노드에 대해 어떻게 생각하는지 보여줍니다. 가십 섹션에는 송신자가 알고 있는 노드 집합 중 무작위로 선택된 몇몇 노드에 대한 정보만 포함됩니다. 가십 섹션에 언급된 노드의 수는 클러스터 크기에 비례합니다.

가십 섹션에 추가된 모든 노드에 대해 다음 필드가 보고됩니다.

- 노드 ID
- 노드 IP 및 포트
- 노드 플래그

가십 섹션을 통해 수신 노드는 송신 노드의 관점에서 다른 노드의 상태 정보를 얻을 수 있습니다. 이는 장애 감지 및 클러스터 내 다른 노드 검색에 모두 유용합니다.

### 실패 감지

Redis 클러스터 장애 감지는 대부분의 노드가 마스터 또는 복제본 노드에 더 이상 접근할 수 없는 상황을 감지하고, 복제본을 마스터 역할로 승격시키는데 사용됩니다. 복제본 승격이 불가능한 경우, 클러스터는 오류 상태로 전환되어 클라이언트의 쿼리 수신을 중단합니다.

이미 언급했듯이, 모든 노드는 다른 알려진 노드와 관련된 플래그 목록을 갖습니다. 장애 감지에는 PFAIL과 FAIL이라는 두 가지 플래그가 사용됩니다. PFAIL은 Possible failure(장애 가능성)을 의미하며, 확인되지 않는 장애 유형입니다. FAIL은 노드에 장애가 발생했으며, 이 상태가 일정 시간 내에 대다수의 마스터에 의해 확인되었음을 의미합니다.

PFAIL 플래그:

노드는 다른 노드에 NODE_TIMEOUT 시간 이상 접속할 수 없을 때 PFAIL 플래그를 표시합니다. 마스터 노드와 복제본 노드 모두 노드 유형에 관계없이 다른 노드를 PFAIL 플래그로 표시할 수 있습니다.

Redis 클러스터 노드의 접속 불가는 활성 ping(전송했지만 아직 응답을 받지 못한 ping)이 NODE_TIMEOUT 시간보다 오래 보류 중인 상태를 의미합니다. 이 메커니즘이 작동하려면 NODE_TIMEOUT 시간이 네트워크 왕복 시간보다 커야 합니다. 정상적인 작동 중 안정성을 높이기 위해 노드는 NODE_TIMEOUT의 절반이 경과해도 ping에 대한 응답이 없으면 클러스터의 다른 노드에 다시 연결을 시도합니다. 이 메커니즘은 연결이 유지되도록 보장하므로 끊어진 연결이 노드 간에 잘못된 실패 보고로 이어지지 않습니다.

FAIL 플래그:

PFAIL 플래그 자체는 각 노드가 다른 노드에 대해 가지고 있는 로컬 정보일 뿐, 복제본 승격을 유발하기에는 충분하지 않습니다. 노드가 다운된 것으로 간주되려면 PFAIL 상태가 FAIL 상태로 에스컬레이션되어야 합니다.

이 문서의 노드 하트비트 섹션에 설명된 대로, 모든 노드는 다른 모든 노드에 가십 메시지를 전송하며, 여기에는 몇몇 알려진 무작위 노드의 상태도 포함됩니다. 모든 노드는 결국 다른 모든 노드에 대해 노드 플래그 세트를 수신합니다. 이를 통해 모든 노드는 감지된 장애 상황을 다른 노드에 알리는 메커니즘을 갖게 됩니다.

다음 조건 집합이 충족되면 PFAIL 조건이 FAIL 조건으로 상향 조정됩니다.

- A라고 부를 어떤 노드에 PFAIL 플래그가 지정된 다른 노드 B가 있습니다.
- 노드 A는 가십 섹션을 통해 클러스터 내 대다수 마스터의 관점에서 B의 상태에 대한 정보를 수집했습니다.
- 대다수의 마스터는 NODE_TIMEOUT \* FAIL_REPORT_VALIDITY_MULT 시간 내에 PFAIL 또는 FAIL 상태를 알렸습니다. (현재 구현에서는 유효성 계수가 2로 설정되어 있으므로, 이는 NODE_TIMEOUT 시간의 두 배에 불과합니다)

위의 모든 조건이 참이면 노드 A는 다음을 수행합니다.

- 노드를 FAIL로 표시합니다.
- 도달 가능한 모든 노드에 FAIL 메시지(하트비트 메시지 내 FAIL 조건과 반대)를 전송합니다.

FAIL 메시지는 모든 수신 노드가 해당 노드를 FAIL 상태로 표시하도록 강제합니다. 이는 노드가 이미 PFAIL 상태로 플래그를 설정했는지 여부와 관계없이 적용됩니다.

FAIL 플래그는 대부분 단방향입니다. 즉, 노드는 PFAIL에서 FAIL로 전환될 수 있지만, FAIL 플래그는 다음과 같은 상황에서만 해제될 수 있습니다.

- 노드가 이미 접근 가능하며 복제본입니다. 이 경우 복제본은 장애 조치되지 않으므로 FAIL 플래그를 지울 수 있습니다.
- 노드가 이미 접근 가능하며 슬롯을 제공하지 않는 마스터입니다. 슬롯이 없는 마스터는 실제로 클러스터에 참여하지 않고 클러스터에 참여하기 위해 구성되기를 기다리고 있으므로 FAIL 플래그를 지울 수 있습니다.
- 노드가 이미 접근 가능하며 마스터이지만, 감지 가능한 복제본 승격 없이 오랜 시간(NODE_TIMEOUT의 N배)이 경과했습니다. 이 경우 클러스터에 다시 참여하여 계속 진행하는 것이 좋습니다.

PFAIL -> FAIL 전환에는 일종의 합의가 사용되지만, 그 합의는 약하다는 점에 유의해야 합니다.

1. 노드는 일정 기간 동안 다른 노드의 뷰를 수집하므로, 대다수의 마스터 노드가 "동의"해야 한다고 하더라도, 실제로 이는 서로 다른 시점에 여러 노드에서 수집한 정보일 뿐이며, 특정 시점에 대다수의 마스터 노드가 동의했는지 확신하거나 요구하지는 않습니다. 그러나 오래된 장애 보고서는 폐기하므로, 장애는 특정 기간 내에 대다수의 마스터에 의해 신호가 전달되었습니다.
2. FAIL 상태를 감지한 모든 노드는 FAIL 메시지를 사용하여 클러스터의 다른 노드에 해당 상태를 강제로 전달하지만, 메시지가 모든 노드에 도달할 것이라고 보장할 방법은 없습니다. 예를 들어, 노드가 FAIL 상태를 감지했지만 파티션으로 인해 다른 노드에 도달하지 못할 수 있습니다.

하지만 Redis 클러스터 장애 감지에는 호라성 상태 요건이 있습니다. 즉, 결국 모든 노드가 특정 노드의 상태에 대해 동의해야 합니다. 분할 브레인 조건에서 발생할 수 있는 두 가지 경우가 있습니다. 소수의 노드가 노드가 FAIL 상태라고 생각하거나, 소수의 노드가 노드가 FAIL 상태가 아니라고 생각하는 것입니다. 두 경우 모두 결국 클러스터는 특정 노드의 상태에 대한 단일 뷰를 갖게 됩니다.

Case 1 : 장애 감지 및 이로 인한 체인 효과로 인해 마스터의 과반수가 노드를 FAIL로 플래그 지정한 경우, 지정된 시간 동안 충분한 장애가 보고되므로 결국 다른 모드가 해당 마스터를 FAIL로 플래그 지정합니다.

Case 2 : 소수의 마스터만 노드를 FAIL로 플래그 지정한 경우, 복제본 승격은 발생하지 않습니다.(모든 노드가 승격 사실을 결국 알 수 있도록 하는 보다 공식적인 알고리즘을 사용하므로). 그리고 모든 노드는 위의 FAIL 상태 해제 규칙(즉, NODE_TIMEOUT의 N배가 경과한 후에는 승격되지 않음)에 따라 FAIL 상태를 해제합니다.

FAIL 플래그는 복제본 승격 알고리즘의 안전 부분을 실행하기 위한 트리거로만 사용됩니다. 이론적으로 복제본은 마스터에 도달할 수 없을 때 독립적으로 작동하여 복제본 승격을 시작하고, 마스터가 실제로 다수 노드에 도달할 수 있는 경우 마스터가 확인 응답을 거부할 때까지 기다릴 수 있습니다. 그러나 PFAIL -> FAIL 상태의 복잡성, 약한 합의, 그리고 클러스터의 도달 가능한 부분에서 최단 시간 내에 상태 전파를 강제하는 FAIL 메시지는 실질적인 이점을 제공합니다. 이러한 메커니즘으로 인해 클러스터가 오류 상태일 경우 일반적으로 모든 노드가 거의 동시에 쓰기 허용을 중단합니다. 이는 Redis 클러스터를 사용하는 애플리케이션의 관점에서 바람직한 기능입니다. 또한 로컬 문제(다른 마스터 노드의 대다수가 마스터에 도달할 수 잇는 경우)로 인해 마스터에 도달할 수 없는 복제본이 잘못된 선택 시도를 하는 것을 방지합니다.
