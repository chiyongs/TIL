# 개발자 원칙

테크 리더 9인이 말하는 더 나은 개발자로 살아가는 원칙과 철학

## 1. 덕업 일치를 넘어서

### 덕업 일치를 넘어서

### 덕업 일치의 시작

- 전문가란 무엇일까
- 가트너 신흥 기술 하이프 사이클
  - 기술 촉발 → 과잉 기대 정점 → 환멸기 → 계몽기 → 생산성 안정기

### 테라포밍

- 동기 (동기 요인, 위생 요인)
  - 위생 요인 : 생물로서 생존하기 위한 기본적인 새리적 필요에 대한 것, 부족할 땐 문제가 되지만 넘치도록 채워진다고 만족감 증대 X
  - 동기 요인 : 성장, 도전, 성취, 의미 같은 동기요인, 만족감이 높아지는 쪽으로 기안
- 피터 드러커 “프로페셔널의 조건”
  - 지식 노동자는 시대적 소명임과 동시에 지식 사회인 현대의 가장 기본적인 생산 요소
    개발자 : 공장에 자기만의 생산 설비를 들고 들어가서 일하는 노동자
    그 자체로 생산 시설의 일부, 성과를 내는 주체

### 테크 리드의 길

- 담쟁이 - 도종환
- 소프트웨어는 팀 작업
  - 좋은 팀 분위기 → 의미 있는 성과, 개인과 팀 모두 성장

### 아직도 가야할 길

- 쓸모 있는 일을 하자
- 골드 러시 끝엔 엔지니어링 전문성이 중요
- 개발자 : 이제 그 정체가 서서히 명확해지기 시작한 신종 직군

## 2. 오류를 만날 때가 가장 성장하기 좋을 때다

백엔드 엔지니어의 실력은 얼마나 많은 오류와 장애를 만나고 이를 해결했는지 여부에 따라 갈린다.

> 더 나은 개발자로 나아가는 원칙

1. 오류가 발생하면 소스 코드 레벨에서 이해하자

잘못된 것을 찾는 가장 쉬운 방법 : 스택오버플로우에서 이전에 같은 증상으로 올린 질문과 해답을 찾는 것

서비스를 운영하다보면 많은 툴을 사용하고 많은 에러를 마주치게 된다.

이 때 오류를 스택오버플로우에서 검색하여 쉽게 해결한다면 실제로 깊은 지식을 얻기가 어렵다.

해당 툴의 소스 코드를 확인하는 것으로 관련 에러가 왜 발생하는지 해결하려면 어떻게 해야하는지 같은 깊은 지식을 얻을 수 있다.

파생되거나 비슷한 문제를 예방할 수도 있게 된다.

→ 소스 레벨에서 오류를 확인해야하는 주장의 이유

2. 알아낸 지식을 글로 공개하라

소스 레벨에서 이해한 내용을 결과물로 남기는 것이 중요하다.

개발자로서 성장하는 데 좋은 정보를 뇌에 입력하는 것도 좋지만, 제대로 이해하고 있는지 확인받는 것도 중요

아예 모르는 것보다 잘못 아는 것이 더 위험

가급적이면 결과물을 공개해 다른 사람의 조언을 들을 기회로 삼는 것이 좋다.

### 오래된 오류와의 만남

네이글 알고리즘 : 네트워크의 효율성을 높이기 위해 출력할 데이터가 도착할 때마다 매번 보내는 것이 아니라, 지정된 크기를 모아서 보내는 방식

> 한 걸음 더 나아가기

기술을 공부할 때 왜 이러한 기술이 생겨났는지를 먼저 생각해본다.

네이글 알고리즘은 RFC 896에 소개, RFC 896 : Congestion Control in IP/TCP Internetworks

### 정말인지 소스 코드로 확인하기

자바 8에서 HashMap의 구조가 변경됨

기존에는 선형 리스트 구조였는데 이를 개선하면서 많은 성능을 끌어올림

자바 8 이후 HashMap은 한 해시맵의 아이템이 8개가 되면 선형 리스트 구조에서 해당 부분만 레드 블랙 트리 구조로 변경

HashMap에 속하는 데이터가 6개 이하라면 다시 선형 리스트로 저장

다시 선형 리스트가 되는 경우는 항상 개수가 적을 때 바뀌는 것이 아니라, 해시테이블이 확장되어서 해시테이블의 트리가 두 개로 나눠지는 시점에만 개수를 따라서 다시 선형리스트가 된다.

> 성장하는 개발자

개발자라면 어떻게 하면 더 능력 있는 개발자가 될 수 있을까를 늘 고민한다.

- 성장의 8할은 호기심

개발 도중 떠오르는 의문들에 대해 깊이 아는 것은 크게 도움이 안 될 수도 있지만, 하나하나가 모여 깊이 있는 기술력이 된다.

## 3. 소프트웨어 디자인 원칙

- KISS(Keep It Simple, Stupid) : 간단하게 클래스나 메서드를 만들라는 법칙
- DRY(Do not Repeat Yourself) : 반복되는 기능이나 객체를 하나로 만들어서 관리하라는 법칙
- YAGNI(You Ain’t Gonna Need It) : 코드를 적어나가다 보면 갑자기 머릿속에서 떠오르는 필요한 기능이 있어 막 적지만 결국 안 쓴다는 법칙

이런 원칙들이 정말 맞는 원칙일까?

> 객체지향 프로그래밍의 5원칙 : SOLID

- SRP(Single Responsibility Principle) : 단일 책임 원칙, 각 클래스는 하나의 정보만을 가지게 만들어야 하고, 각 클래스에서 공통적인 특성을 뽑아낼 수 있다면 하나의 슈퍼세트 클래스로 옮긴 다음 변화하는 특성만 상속이나 구현으로 처리하는 원칙
- OCP(Open Closed Principle) : 개방 폐쇄 원칙, 확장에는 열려있지만 변경에는 닫혀있어야 한다.
- LSP(Listov Substitution Principle) : 리스코프 치환 원칙, 인터페이스의 서브타이핑은 인터페이스에 정의된 형식을 최대한 유지해야 한다.
- ISP(Interface Segragation Principle) : 인터페이스 분리 원칙, 인터페이스는 최소한으로 유지해야 한다.
- DIP(Dependency Inversion Principle) : 의존 관계 역전 원칙, 상위 레벨의 모듈이나 인터페이스가 서브 클래스나 타이핑에 영향 받아서는 안된다.

SOLID 원칙은 소프트웨어의 ‘유연성, 확장성, 유지보수성’을 갖추게 하는데 필요하다.
이러한 원칙을 가지고 있지 않은 소프트웨어가 가지는 문제점 : 디자인 악취 (Design Smell)

> 디자인 악취 : Design Smell (in 클린 소프트웨어)

- 경직성 : 프로그램 변경이 어렵다.
- 취약성 : 일부의 변경으로 아무 연관 없는 부분에서 장애가 발생한다.
- 부동성 : 재사용할 수 있는 컴포넌트를 구분하기 어렵다.
- 점착성 : 기존 디자인에 적용된 철학이나 방식을 유지하기 어렵거나 비효율적인 경우
- 불필요한 복잡성 : 직접적인 효용이 전혀 없는 기반 구조가 디자인에 포함된 경우
- 불필요한 반복 : 단일 추상 개념으로 통합할 수 있는 반복적인 구조가 디자인에 포함되어 있다.
- 불투명성 : 직접 만든 사람이 아닌 다른 사람이 코드를 이해하기 어렵다.

이렇게 오래된 원칙을 그대로 받아들여야 하는지는 고민해봐야 한다.

디자인 악취는 원인이 아니고 결과이다.

### 디자인이란 무엇인가?

디자인의 한국말 : 설계

설계의 사전 뜻

1. 계획을 세움
2. 건축물 설립이나 토지 공사, 기계의 제작 따위에서 그 목적에 따라 실제적인 계획을 세우고 구체적으로 도면을 그려 명시하는 일

2번이 우리가 주로 소프트웨어 제품을 개발할 때 적용해볼 수 있는 의미
설계 : ‘목적’에 따라서 ‘실제적인 계획’을 세우고 ‘구체적으로 도면’을 그려 명시하는 일

### 설계와 요구사항

설계 전에 요구사항을 잘 정의해야 요구사항을 만족시키는 지 증명할 수 있다.

스티브 잡스 : 소비자는 제품을 보여주기 전까지 자신이 뭘 원하는 지 모른다

→ 생산자라도 어떤 제품을 만들지 명확하게 정의해야 한다.

요구사항은 항상 수치화되어 있어야 한다.

### 소프트웨어 설계 원칙 : 통합적으로 설계하라

IEEE-830 SRS(Software Requirement Specification) : 정확하고, 모호하지 않으며, 완결적이고, 일관적이고, 우선순위나 안정성의 순서로 정렬되어 있고, 증명 가능하고, 수정 가능하고, 이런 요구사항을 추적 가능해야 한다.

하지만, 이렇게 많은 특성을 가져야 하는 SRS을 작성하는 일은 쉽지 않다.

→ 표준화된 도구가 없기 때문

제품을 종합적으로 설계하는 방법

- 명시적 설계(explicit design)
- 암묵적 설계(implicit design)

### 명시적 소프트웨어 설계

명시적 소프트웨어 설계 : 기본적으로 명시적으로 요구사항과 연결되는 설계

만들 것이 명확하게 정의 → 비교적 단순, 직관적으로 설계 가능 & 테스트, 증명도 쉬움

- 기능
  - SRS, 사용자 요구사항을 해결하는 1차적이고 가장 기본적, 중요한 설계
  - 새로 만들거나 개선할 기능을 SRS 기반으로 정의, 기능을 만조갛는지 수치적으로 증명할 수 있는 조건 정의
- 성능
  - 대부분의 기능 요구사항에 대응하는 설계의 결과물은 바이너리 형태
  - 해당 기능이 어느 정도 성능이 필요한지를 정의할 때부터 복잡해짐
  - 따라서, 대부분 아키텍처 설계 문서만 있고 대부분 시험 절차로 대체
  - 클라우드가 많이 사용되면서 성능에 대한 것도 문서화가 가능해짐
- 유지보수
  - 소프트웨어는 만들어지면 거의 평생 사용됨
  - IT 서비스 초기에는 각 서비스별로 배치 또는 배포 시스템을 만들고 관리하는 일이 큰 일이었음
  - 도커와 쿠버네티스 등장으로 유지보수가 매우 쉬워짐
- 미적 설계
  - 사용자에게 물리적, 심리적으로 즐거움과 편리함을 줄 수 있도록 미적 설계가 필요함
  - 소비자가 해당 제품을 사용할 방법들을 미리 정의 → 사용자 인터페이스, 정보 아키텍트, 프로토타이핑, 사용성 검증이 필요
    - 사용자 인터페이스 : 사용자가 제품을 만나게 되는 접점
    - 정보 아키텍트 : 내부 시스템은 크게 신경 쓰지 않고 정보를 배치하는 일 (구조화 시스템, 라벨링 시스템, 검색, 내비게이션 시스템), 이 과정에서 페이지 계층이나 화면 흐름도가 산출물로 나옴
    - 프로토타이핑 : 정보 아키텍트를 검증할 목적으로 아주 간단한 정보 구조를 만들어보는 것
    - 사용성 검증 : 요구사항을 만족시키는 조건을 결정할 때 반드시 검증을 고려해야 함, 꼭 수치화해서 검증해야 함

### 암묵적 소프트웨어 설계

암묵적 설계는 SRS에 직접적으로 명시 X, 하지만 비즈니스나 기획 심지어 개발에서도 그 일을 수행함

대부분의 항목들은 소프트웨어의 기본에 속함

> Facts and Fallacies of Software Engineering

사실 41. 유지보수는 소프트웨어 전체 비용 중에 40~80%를 소비한다. 그리고 아마도 소프트웨어 사이클에서 가장 중요한 영역이다.

사실 42. 개선하는 데는 유지보수 비용의 60% 정도가 필요하다.

암묵적 설계는 유지보수만을 위한 설계는 아니지만 많은 부분이 소프트웨어 제품을 지속적으로 운영하는 데 필요한 요소를 고려한다.

하지만, 이를 다 고려하면서 기능까지 구현해내기까지 시간이 너무 오래 걸림

→ 대개 빨리 기능을 구현해서 출시 & 수익 창출
→ 암묵적 설계는 오퍼레이션 영역으로 치부됨

현대의 소프트웨어는 명시적 설계와 암묵적 설계를 나누는 방식을 선호 X

예시) ‘클릭’ : 기능, ‘천 번 클릭’ : 성능도 포함

분리한다면 기능만 보는 조직과 성능과 안정만을 보는 조직이 생기기 때문

명시적 설계 : 4가지 요소, 암묵적 설계 : 4가지 항목 & 13가지 요소

> 암묵적 설계 4가지 항목

- 서비스 지속성 설계 : 출시된 서비스가 지속적으로 실행되는 데 문제가 없도록 하는 설계 요소들
  - 가용성 설계
    - 소프트웨어 설계 초기에 가장 많이 누락되는 항목
    - 제품 초기 : 평균 무고장 시간은 100일, 평균 수리 시간 : 12시간 정도로 설계해야 함
  - 용량 설계
    - 처리해야 하는 트래픽양, 평균 응답 시간 등 수치적인 조건이 만들며 이에 대한 고민이 필요
  - 연속성 설계
    - 소프트웨어 제품이 중단되지 않고 실행할 조건을 미리 설계
    - 가용성과 비슷, 하지만 소프트웨어가 끊임없이 서비스되게 설계하는 점이 다름
  - 보안 설계
    - 데이터의 기밀성과 정합성에 대한 수준을 수치적으로 제시하는 조건을 설정
    - 대표적으로 CVSS(Common Vulnerability Scoring System) 점수 목표를 설정, 그에 따른 컴포넌트들을 설계에 포함해야 함
- 서비스 전환 설계 : 소프트웨어는 새로운 기능을 제공 → 이전 버전과 더는 호환되지 않아서 기존 제품을 폐기하는 경우도 존재 → 반드시 서비스의 전환에 대한 설계 필요
  - 변환 설계
    - 소프트웨어 제품이 추가되거나 기능이 새롭게 개발되거나 폐기되었을 때 기존 제품에 미치는 영향을 최소화하는 설계 요소
    - 레거시..
  - 릴리즈 설계
    - 메이저 버전 업그레이드 or 릴리즈할 정도의 소프트웨어 완성인지에 대한 설계 (테스트 계획으로 통용됨)
  - 설정 관리 설계
    - 가장 많은 장애와 오류를 만드는 원인 : 잘못된 설정
    - 설정에 대한 근거를 수치적으로 제시해야 함
- 서비스 운영 설계 : 릴리즈된 소프트웨어가 설계된 조건을 만족하도록 하는 설계
  - 장애 대비 설계
    - 제공되는 서비스가 외부의 상황이나 내부의 컴포넌트 중단에 영향을 받지 않도록 설계
    - 실제 장애 발생 시 수치에 따라 정해진 등급대로 행동을 지정, 매뉴얼 활용
  - 요구 수행 설계
    - 사용자 문의에 대한 대답, 소프트웨어에 대한 컨설팅을 실행하는 것도 미리 설정하고 수치적으로 표현해야 함
  - 문제 대응 설계
    - 장애 : 보통 예측하지 못한 사고
    - 문제 : 소프트웨어의 개발이나 실행/운영 과정에서 예측이 가능한 프로세스의 문제점이나 구조적인 문제점들
    - 주로 취약점 분석으로 나타남 → 기술적 부채로 부르는 문제를 어떻게 다룰지 미리 설계 필요
- 서비스 개선 설계 : 소프트웨어가 실제 환경에서 실행되는 순간부터 정말 문제없이 정해진 일들을 수행하는지에 대한 지표 확인 & 개선 준비
