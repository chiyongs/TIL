# JVM 이해하기

## 자바, JVM, JDK 그리고 JRE

### JVM

Java Virtual Machine, 자바 가상 머신으로 자바 바이트 코드(.class)를 인터프리터와 JIT 컴파일러를 사용하여 OS에 특화된 코드로 변환하여 실행한다.

바이트 코드를 실행하는 표준이자 구현체이다.
→ JVM 자체는 표준이나 특정 벤더들이 자신들의 입맛에 맞게 구현한다. (JVM 벤더 : 오라클, 아마존, Azul)

특정 플랫폼에 종속적이다. (네이티브 코드(OS)에 맞춰서 실행해야 하기 때문)

### JRE

Java Runtime Environment, 자바 애플리케이션을 실행할 수 있도록 구성된 배포판이다.
JVM과 핵심 라이브러리, 프로퍼티 세팅, 리소스 파일들을 가지고 있다.
개발 툴은 포홤되어 있지 않다.

### JDK

Java Development Kit, JRE + 개발에 필요한 툴이 들어있다.
소스 코드를 작성할 때 사용하는 자바 언어는 플랫폼에 독립적이다.
오라클은 자바 11부터 JDK만 제공하고, JRE를 따로 제공하지 않는다.

### Java

프로그래밍 언어이다.
JDK에 들어있는 자바 컴파일러(javac)를 사용하여 바이트코드(.class 파일)로 컴파일할 수 있다.

## JVM 구조

JVM은 크게 보면 4가지로 분류할 수 있다.

### 클래스 로더 시스템

자바 바이트코드를 읽어 메모리에 저장하는 것이 주로 하는 일이다.

- 로딩 : 클래스를 읽어오는 과정
- 링크 : 레퍼런스를 연결하는 과정
- 초기화 : static 값들을 초기화하며 변수에 할당

### 메모리

스택, PC, 네이티브 메소드 스택은 각각의 쓰레드에 국한되어있다.
힙, 메소드는 여러 쓰레드에서 공유하여 사용 가능한 자원이다.

- 스택
  - 쓰레드마다 런타임 스택을 만들고, 그 안에서 메소드 호출을 스택 프레임 블럭으로 쌓는다.
  - 쓰레드가 종료하면 런타임 스택도 사라진다.
- PC
  - Program Counter 레지스터, 쓰레드마다 쓰레드 내 현재 실행할 instruction의 위치를 가리키는 포인터가 생성된다.
- 네이티브 메소드 스택
  - 네이티브 메소드 : 메소드에 native라는 키워드가 붙어있고, 구현을 Java가 아닌 C나 C++로 되어있는 메소드이다.
  - JNI을 통해 메소드가 호출되면 네이티브 메소드 스택에 쌓인다.
  - ex) Thread.currentThread()
- 힙
  - 객체(인스턴스)를 저장한다. 다른 영역에 공유되는 자원이다.
- 메소드
  - 클래스 수준의 정보(클래스 이름, 부모 클래스 이름, 메소드, 변수)를 저장된다.
  - 메소드 영역에 저장된 정보들은 다른 영역에서도 참조할 수 있는 공유되는 자원이다.

### 실행 엔진

- 인터프리터
  - 바이트 코드를 한 줄 씩 실행한다.
- JIT 컴파일러 (Just In Time 컴파일러)
  - 바이트 코드를 네이티브 코드로 컴파일해준다.
  - 인터프리터의 효율을 높이기 위해 인터프리터가 반복되는 코드를 발견하면 해당 코드를 JIT 컴파일러로 네이티브 코드로 바꿔둔다. 그 후 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용한다.
- GC
  - Garbage Collector, 더 이상 참조되지 않는 객체를 모아서 정리한다.
  - 크게 2가지로 나누면 Throughput 위주의 GC와 Stop-the-world 위주의 GC가 있다.
    - 서버 운영 중에 굉장히 많은 객체를 생성하고 Response 타임이 중요한 경우
      - Stop-the-world 시간을 줄이는 GC를 사용하는 것이 좋다.

### JNI & 네이티브 메소드 라이브러리

- Java Native Interface, 자바 애플리케이션에서 C, C++, 어셈블리로 작성된 함수를 사용할 수 있는 방법을 제공
- 네이티브 메소드 라이브러리 : C, C++로 작성된 라이브러리

## 클래스 로더

클래스 로더 시스템은 크게 3가지 단계로 진행된다.

- 로딩, 링크, 초기화

### 로딩

- Application ClassLoader → Platform ClassLoader -> Bootstrap ClassLoader
  - 클래스 로딩을 진행할 때 자식 클래스 로더에서 먼저 찾아보고 찾지 못한 경우 부모 클래스 로더에게 위임한다.
- 클래스 로더가 .class 파일을 읽고 그 내용에 따라 적절한 바이너리 데이터를 만들고 “메소드” 영역에 저장
  - 메소드 영역에 저장되는 데이터
    - FQCN (Fully Qualified Class Name)
    - 클래스 | 인터페이스 | 이늄
    - 메소드와 변수
- 로딩이 끝나면 해당 클래스 타입의 Class 객체를 생성하여 “힙” 영역에 저장
- 부트스트랩 클래스 로더
  - JAVA_HOME/lib 에 있는 코어 자바 API를 제공한다.
  - 최상위 우선순위를 가진 클래스 로더, 네이티브로 구현된 클래스 로더
- 플랫폼 클래스 로더
  - JAVA_HOME/lib/ext 폴더 또는 java.ext.dirs 시스템 변수에 해당하는 위치에 있는 클래스를 읽는다.
- 애플리케이션 클래스 로더
  - 애플리케이션 클래스패스(애플리케이션에서 실행할 때 주는 -classpath 옵션 또는 java.class.path 환경 변수 값에 해당하는 위치)에서 클래스를 읽는다.

### 링크

- Verify → Prepare → Resolve(optional) 세 단계로 이루어진다.
- Verify, 검증
  - .class 파일 형식이 유효한지 체크한다.
- Preparation
  - 클래스 변수(static 변수)와 기본 값에 필요한 메모리를 준비하는 과정
- Resolve
  - 심볼릭 메모리 레퍼런스를 “메소드” 영역에 있는 실제 레퍼런스로 교체하는 과정
    - 심볼릭 메모리 레퍼런스 : 논리적인 레퍼런스
