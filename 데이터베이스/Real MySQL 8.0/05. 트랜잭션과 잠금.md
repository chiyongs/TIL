# 5.1 트랜잭션

## 트랜잭션

트랜잭션 : 작업의 완전성을 보장해주는 기능 → 논리적인 작업 세트가 100% 처리되거나, 원상태로 복구되거나를 보장해줌

- 락 : 동시성을 제어하기 위한 기능
- 트랜잭션 : 데이터의 정합성을 위한 기능

MySQL에는 3가지 스토리지 엔진 존재

- MyISAM → 트랜잭션 미지원
- MEMORY → 트랜잭션 미지원
- InnoDB → 트랜잭션 지원

트랜잭션을 지원하지 않으면 부분 실행이라는 것이 발생할 수 있다.
부분 실행은 쿼리 수행 시 예외가 발생했거나 실패했을 때 해당하는 쿼리 전으로는 적용되는 것을 말함
따라서, 부분 실행으로 인해 변경된 데이터에 대해서 어떻게 처리할 것인가에 대한 고민이 필요함.
→ 트랜잭션이 애플리케이션을 개발하는 데 있어 고민할 부분을 덜어준다고 볼 수 있음

트랜잭션은 DB 커넥션처럼 최소화해서 사용하는 것이 좋음.

## 락

- MySQL 엔진 : 스토리지 엔진을 제외한 MySQL
  - MySQL 엔진 레벨의 락은 스토리지 엔진 레벨 락에 영향을 준다.
- 스토리지 엔진

### MySQL 엔진 락 종류

글로벌 락

- 모든 세션에 대해 잠금하는 락
- 조회를 제외한 모든 작업이 불가능
- `FLUSH TABLES WITH READ LOCK`

백업 락

- 특정 세션에 대해 잠금하는 락
- 데이터베이스 및 테이블 같은 객체 생성,변경,삭제 금지 & 사용자 권한 및 비밀번호 변경 금지
- but, 일반적인 테이블의 데이터 변경은 허용
- `LOCK INSTANCE FOR BACKUP`

테이블 락

- 개별 테이블을 잠금하거나 해제하는 락
- 명시적 또는 묵시적으로 획득할 수 있음
- `LOCK TABLES table_name [ READ | WRITE ]`
- InnoDB에서 데이터 변경 시 테이블 락 적용, 대부분 DML들은 락을 무시, 스키마를 변경하는 등의 DDL은 락에 영향받음

네임드 락

- 사용자가 지정한 문자열을 잠금하거나 해제하는 락
- 잘 쓰이지는 않으나, 많은 레코드에 대해 복잡한 조건으로 변경을 진행하는 배치 작업에서 동시성을 위해 사용할 수 있음
- `SELECT GET_LOCK('mylock', 2)` : "mylock" 문자열에 대해 락을 획득
- `SELECT IS_FREE_LOCK('mylock')` : "mylock" 문자열에 대해 락이 설정되어 있는지 확인
- `SELECT RELEASE_LOCK('mylock)` : "mylock" 문자열에 대해 획득했던 락을 반납

메타데이터 락

- 데이터베이스 객체의 이름이나 구조 변경 시 걸리는 락
- 명시적으로 획득할 수 없음
- `RENAME TABLE table_a TO table_b`

### InnoDB 스토리지 엔진 락 종류

InnoDB는 레코드 기반의 락을 사용해서 동시성이 좋다.

레코드 락

- 다른 상용 DBMS와 같이 레코드에 락을 건다.
- 레코드 자체에 락을 걸지 않고, 레코드의 인덱스에 락을 건다 → 성능 상 이점을 가져감
- 인덱스가 없는 테이블이라면 내부적으로 생성된 클러스터 인덱스에 락을 건다.

갭 락

- 레코드와 레코드 사이에 락을 건다.
- 레코드 사이에 다른 데이터가 insert되는 것을 제어한다.

넥스트 키 락

- 레코드 락과 갭 락을 같이 사용하는 락
- STATEMENT 바이너리 로그 + innodb_locks_unsafe_for_binlog → 넥스트 키 락
- 바이너리 로그에 기록된 쿼리를 사용하는 레플리카 서버에서 동일한 값을 만들기 위한 것이 주 목적

자동 증가 락 Auto increment lock

- AUTO_INCREMENT 속성이 걸려있는 값에 insert, replace 명령어를 수행하면 락이 걸린다.
- auto_increment 값을 가져올 때만 락을 걸고 값을 받으면 락을 해제한다.
- 짧게 락을 가져간다.
- 테이블에는 단 하나의 AUTO INCREMENT LOCK이 존재한다.
- 한 INSERT 문장이 자동 증가 락을 가지고 있으면, 다른 INSERT 문장은 기다려야 한다.
- MySQL 5.0 이하에서는 AUTO INCREMENT LOCK만 사용
- MySQL 5.1 이상에서는 innodb_autoinc_lock_mode 사용
- innodb_autoinc_lock_mode
  - 0 → AUTO INCREMENT LOCK 사용
  - 1 → INSERT 되는 레코드 건 수를 정확히 알 땐 래치(뮤텍스) 사용, 모르면 자동 증가 락 사용
    - 한 INSERT 문장에서 추가된 레코드들은 연속된 증가 값을 보장
    - 대량의 INSERT 시 AUTO INCREMENT 값을 한번에 받아오기 때문에 값이 남으면 버림
    - 완벽하게 증가된 값은 아님
  - 2 → 자동 증가 락 사용하지 않고, 래치만 사용, 인터리빙 모드
    - 한 INSERT 문장 내 추가된 레코드들에 대해 연속된 증가 값을 보장하지 않음
    - INSERT 된 레코드들이 유니크한 값을 가지는 것만 보장
    - MySQL 8.0 부터는 ROW 바이너리 로그 사용하여 기본 값 채택

## 인덱스와 락

MySQL InnoDB 스토리지 엔진 : 레코드 기반 락
레코드의 인덱스에 락을 건다.
→ 검색한 인덱스에 모두 락을 건다.

만약, 인덱스가 없는 테이블이라면 풀 스캔을 하게 되고 풀 스캔 시 모든 레코드가 락에 걸린다.
→ 적절한 인덱스가 없으면 동시성이 떨어진다.
